<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Transcription of Plan 9, Not Dead, Just Resting, by Ori Bernstein | fpiorlblog</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="https://fpiorl.github.io/posts/transcription-of-plan-9-not-dead-just-resting-by-ori-bernstein/">
  <meta property="og:site_name" content="fpiorlblog">
  <meta property="og:title" content="Transcription of Plan 9, Not Dead, Just Resting, by Ori Bernstein">
  <meta property="og:description" content="N.B. This file was generated using artificial intelligence without a GPU.
Transcript Hello and welcome to BSD TV. This is a video of Ori Bernstein&#39;s October 2019 Nice Bug Meeting entitled Plan 9, Not Dead, Just Resting. Ori is someone I&#39;ve been running into at BSD CANS over the last few years. This current Westcoaster was nice enough to stop by the New York BSD Users Group, and for the true New York experience, we got a visit from the New York City Fire Department during his talk. Thankfully, it was a false alarm and Ori&#39;s talk was a success. attended with lots of new faces and engaging questions. Enjoy. I&#39;m going to be talking about Plan 9, as you can see. So what, a summary of what&#39;s happened to it, or what&#39;s happening with it, why you don&#39;t want to use it, why I use it anyways, and generally the state of the union. And of course, what people can learn from it, even if they&#39;re not using Plan 9. So, it&#39;s already been covered, but feel free to interrupt me if any If there are any questions, I&#39;d rather go off track or go and beat around the bush a little bit rather than just lose people or bore people. So just feel free to stop me and ask questions. So who am I? What do I do with Y Plan 9? So yes, I do have a Plan 9 laptop. It&#39;s that one over there. This one&#39;s actually running OpenBSD because I don&#39;t trust Plan 9&#39;s dual monitor output working on it. This one, but I am running this presentation remotely. over plan nine so you&#39;re getting the real deal um I use it regularly I actually write code on it I log into other systems and develop code from plan nine sometimes and yes that probably means there is something wrong with me I am definitely way too stuck um okay so why don&#39;t you want to use plan nine well it doesn&#39;t have the programs you want this uh came from the uh nine fans mailing list uh years and years ago and it details a typical new user&#39;s experience with Plan 9. Hi, I&#39;m Nita Plan 9. I&#39;m really excited to work with this new Linux. I hit some questions. How do I run X11? Where is Emacs? The code is weird. It doesn&#39;t look like GNU C at all. Do the Plan 9 people who wrote Plan 9 know at all about C? I tried to run Mozilla, but it didn&#39;t work. How come? You can tell this is an old post because it refers to Mozilla. Anyways, sorry, there is no X11 asterisk. Plan9 does its graphics through the dev draw device, keyboard FS, dev mouse, and real. I&#39;ll go into a bit more detail on that. So that star actually is because the slide went out of date this September. Someone actually got an old port of X11 working, and you can now basically run x programs on a Unix machine and have them display on Plan 9. Although amusingly enough, we got Chrome working before we got X-File. Yeah. So, yes. So Plan 9 has a Sage file? Yes. Can you do a Sage X-forwarding or a Sage? I don&#39;t believe so. I don&#39;t think that the X-forwarding channel has been implemented. So this is the Emacs methodology. And I&#39;m not joking. That is the actual man page. There is no Emacs. There is a man page for Emacs describing why they, that they don&#39;t, making it very clear that they do not like Emacs. And it was intentionally left out. There is VI. That&#39;s not the right VI. VI is a mix emulator. Someone has ported Vim. But I&#39;ve never actually tried using that. The web browsers are, to be blunt, crap. You have two web browsers shipped with the system. One is called Mozilla, one is called Apache. I will show them to you. They don&#39;t do Chrome, they don&#39;t do CSS, they don&#39;t do JavaScript. Does this use HTTPS? Yes, they do. Everything does HTTPS because the browsers don&#39;t actually do HTTP. You have WebFS that does HTTPS. HTTP for them. This is Mothra. Oh, I have not started WebFS on this thing. This is how Google works on PlanB. Well, it&#39;s pretty good. And it&#39;s actually kind of usable. TLS yeah that&#39;s the play all the in order to use the internet these days you need to use one of those garbage browsers like Firefox because the other things don&#39;t support TLS well they get a technology but this does yeah what is nice bug yeah sure oh yeah sorry to be totally off the bat about me but all right nice bug.org yeah That&#39;s actually not bad. Yeah. It&#39;s pretty good. Yeah. I can actually use that. It&#39;s a really simple HTML. It won&#39;t render anything. No, it will not. So it&#39;s actually a standards compliant browser. Relatively. Yeah. Yeah. DuckDuckGo. Okay. Oh wow. Yeah, I&#39;ve got a version that if you turn it on it&#39;ll it&#39;ll display this. Well, even no JavaScript version, right? Yeah, it goes to that process. Anyways, that&#39;s why I cut it off. So that&#39;s the web browser situation. You probably don&#39;t, that probably kills a lot of the usage. But, so that&#39;s what Plan 9 isn&#39;t. system that you can probably that you uh that runs your modern programs that you expect on Unix. Uh it&#39;s not POSIX it doesn&#39;t uh anything you want will probably be there&#39;s a POSIX emulation layer but it&#39;s not very good porting is a chore a lot of the time it&#39;s easier to run your own or to write your own. So it&#39;s not uh a Unixy system but it is a Unix-inspired minimalist distributed graphical text-oriented research operating system. That kind of covers most of it but it&#39;s a bit of a mouthful so let&#39;s break it down uh well the short summary slightly more facetiously is imagine all the good things you they told you were true about actually the good things they told you about unix were true well so first off it came from bell so it&#39;s got the same sort of design aesthetic as unix very minimalist very text oriented everything&#39;s designed around hierarchies of files But it&#39;s also uh yeah it&#39;s minimalist so much more minimalist than Unix. You&#39;ve got 50 system calls you&#39;ve got a very a much smaller number of programs uh the and things are kind of put together by assembling namespaces. Um it&#39;s Unix inspired so you know it&#39;s kind for many people it ends up kind of in the uncanny value of Unix. You know it&#39;s kind of like familiar but not really you know imagine your mom going for plastic surgery and coming back she looks kind of similar but you know there&#39;s a difference so distributed most of the time people use the word distributed to imply fault tolerance resilience and so on so I kind of hesitated using this word here but it is a distributed system the parts of it are not all on the same machine so draw term is that actually is what I&#39;m using to remote into that box. And the way it works is actually by, sorry I&#39;m a little bit sick, by pulling in parts of that system&#39;s namespace into this machine. It runs it, it&#39;s it, it&#39;s actually basically a stripped down emulated Plan 9 kernel running in user space that does the remote login. So it&#39;s kind of a crazy way to do it, but it works. And of course you&#39;re pulling you build the system by pulling in resources from other systems. I&#39;ll go into more detail on that later. Graphics. So you can&#39;t actually use Plan 9 effectively without it without graphics. The way that Plan 9 is designed you really want to have some sort of graphical terminal so that you can actually do things. The command line without graphics is extremely extremely variable it doesn&#39;t give you command line history it doesn&#39;t give you line editing so you can&#39;t actually mouse arrow back and forth edit the text you&#39;ve already typed it doesn&#39;t give you really anything because that&#39;s all be pushed into the Windows system so any any text is managed by the Windows system so for example you can see LS I have got that listed I can click back here and edit the scroll back and that&#39;s how you do the line editing if you want to let&#39;s pull up acid I don&#39;t care I&#39;m just getting some stuff into the history from outside the program and then quote quote quote pulls up history not easy yeah And you can see I&#39;m actually looking through dev text and I can find the previous lines. The code script is used for rerunning command line programs. I forgot that it actually looks for the prompt in the front for it so it filters out the... So the demo didn&#39;t quite do what I wanted, but you can actually look through all the command line history, poke at it, and that&#39;s done through the Windows system, not through the shell itself. Okay. So graphical, text-oriented. As you can see, there&#39;s not, everything&#39;s graphics, but all the graphics that it&#39;s showing right now are text. Everything&#39;s designed around manipulating text, splitting lines through text, and so on. And it&#39;s kind of designed around, well, the entire point of all the graphics is to make it easier to deal with text. It&#39;s also a research operating system. So the design of it is, part of the reason it&#39;s so simple is because it&#39;s a lot easier to mess with the system if you don&#39;t have tons and tons of his-ossified history. Uh, the- it comes with a bunch of research papers. Um, I- here I can actually make this lot bigger more easily. Uh, oops. Uh, we just type a new button. Type a new button. Oh yeah, yeah sure. You can type If I want to type a new window Yeah, so the Yeah, this is annoying I accidentally deleted my font size setting But you okay, so it comes with a bunch of research papers And so just to summarize the differences for graphics instead of Excel you&#39;ve got RIO which is the Windows system. Instead of the ship instead of born shell you&#39;ve got RC. RC is has a lot of useful features on top of born like having lists so you don&#39;t have to worry about word splitting killing your killing any script that has spaces. This is probably the most useful change in RC but overall it&#39;s a much more regular and less quirky syntax. The editors you get Sam and Acme instead of Emacs and Vim. For password management you get Factotum which is kind of the equivalent of SSH agent and SecStore on an off-server which actually securely stores your password. X11 is replaced with KeyboardFS, Draw, Mouse. NFS you get ExportFS over 9P. So that&#39;s the details of that. And a whole bunch of innovations that came out of research on Planet Earth. include UTF-8 which was apparently done in a diner in New Jersey. Are? Seriously? Yes. Yeah, seriously. Wow. Jersey represents. Yeah. Basically they kind of, the story is, there&#39;s a much better summary of it than I can give right now online, but in a minute or so they basically looked at what some standards body, I think IBM, was proposing, went, this isn&#39;t very good, let&#39;s do it better before they actually ratify the standard. So they did, and now we have UTF-8. The proc file system on Linux, that came from Plan 9 indirectly. Ported of compositing, which is the whole drawing with transparency and so on. Plan 9 did that first. The X11 X render extension explicitly mentions Plan 9 as the inspiration. Namespaces, like you&#39;d use in Docker, those came from Plan 9 communicating sequential processes so for example the communication model of Erlang and Go a lot of the initial implementation came from the Plan 9 research environment it&#39;s not the only place that that happened Tony Cor did not work on that on Plan 9 but it&#39;s one of the places where they really started experimenting with it and it looks like you&#39;re taking a picture so I will pause okay so cool and that&#39;s what Happened at Bell Labs. Bell Labs died. So What&#39;s happened since? Well There are a bunch of forks There is nine legacy or plan nine contract which is really a collection of patches nine Adam Harzi nine front Apero is next plan B inferno Probably more forks from users at this point maybe actually I don&#39;t think that&#39;s true I think there are more users than forks but I wouldn&#39;t bet on it anyways so quick summary of what these forks are there&#39;s nine legacy which is essentially a patch collection for the labs version of plan so they&#39;re not taking and really modifying it too much but they are collecting fixes new toys new hardware support and so on they&#39;re keeping the most important patches in the Git repo, the rest are just kind of apply as you like. Nine Atom is, again, Sigma, it&#39;s taking the Bell Labs stuff. They&#39;re not really touching the artwork. But they are just adding some hardware support to it. I&#39;m not sure what the current status of that is. The site seems to be down, but it&#39;s what these things come up and go down as stuff happens. And I believe Nine Atom is just one person. So there&#39;s Harvey. which is more modern modern uh more Unixy they&#39;re trying to actually make the uh POSIX environment good enough to run Unix programs without spending weeks porting them uh they&#39;re trying to port to move the compiler suite to GCC and clang they&#39;re trying to uh hook it up to I don&#39;t remember um I think they&#39;re trying to add the sanitizers all of the nice toys there&#39;s uh ACROS which is a research work that the University of Berkeley maintains and they&#39;re basically trying to do multi-core multi-core multi-core exploring a bunch of new ideas trying to figure out how to make multi-process a more native concept they&#39;re doing some neat stuff and pulling in a whole bunch of Linux eBICS as well I think they&#39;ve started using RCU for performance sake within the Plan 9 kernel instead of locking RCU is essentially read copy update which is block free multi-reader single writer concurrency I can go into more detail about that later if people have questions but I&#39;m not going to go too deep into that there&#39;s Inferno which is another it&#39;s not really a fork it&#39;s another interesting OS designed around Plan 9 but it&#39;s runnable on top of other operating systems too so if you want it Flang 9-ish system that can that you can run on top of Windows, Mac OS, Linux, Plat 9, and so on, as well as on bare metal, even down to machines with one megaram and no MMU. They do that. They&#39;ve written that in which is a JIT compiled language kind of like which runs on something vaguely like the JVM. It&#39;s a neat system. I haven&#39;t done too much with it, but yeah, so that exists. And then there&#39;s 9Front, which is the one that I use. It&#39;s actively maintained. It has great hardware support as far as these things go. So by great hardware support, I mean I can pick, say, ThinkPads and not spend years and years of digging to find some sort of support in hardware. Like I&#39;m using an X260. I&#39;ve got Wi-Fi. I&#39;ve got native resolution and so on. I think writing drivers using binary blobs native drivers so so they barely have enough users but they have developers who are writing yes reverse engineering or taking open source drivers uh the the hardware support is still not it&#39;s not giant but as far as so i&#39;m sorry what are the chips that&#39;s not the drill into this but i&#39;m just curious which groups support you know uh which chip oh wi-fi yeah wi-fi It&#39;s basically DINTL chips. DINTL? Yeah. I think it&#39;s IW. There are some ancient ones that are supported. I&#39;ve got a slide on that too. Oh, I should show you. So most of the Ninefront developers, or the main ones, are German. So of course I have to show you the German engineer. Oh yeah, I made a little click on that. And that, I said text-oriented. It knows there&#39;s, it&#39;s a J, it&#39;s Png. knows where the PNG is and it goes okay I should open that in the PNG viewer I thought it was a hard copy picture for the projection no no no so basically the plumber is a neat piece of another neat piece of engineering basically what you do is you send it messages it looks at the message and goes so what can I do with this text is it a C file in my current directory or a C file that I know about let me open it the editor. Is it a URL? Let me open it in the browser. Is it a message from the email program? Okay, I should show a notification that you&#39;ve received mail. And so on and so forth. So it&#39;s all text-based. You can, and you just, in this case, middle-click on it and it just says, okay, do your thing. Can you do it without a mouse? No, not really. There&#39;s a... file association it&#39;s it&#39;s actually looking at the file header it can yeah it&#39;s not just like oh this is a phg opens picture it&#39;s more than that right uh you can do that i believe it&#39;s you can basically attach any arbitrary script uh but you can do it in the os yes but it&#39;s at the level of the like the windowing system that recognizes it like it chums it into uh the file name it&#39;s not It&#39;s not within the editor. It&#39;s not and it&#39;s not like strictly like half specific is it? Like as long as it goes it goes through the policy and finds like policy says German engineering at the end of the chain so it says okay I found it open it. It&#39;s just like using magic words and operating systems. Like you literally modify it right there on the spot and just add new things to it. That&#39;s cool. Okay, here we go. So here are the rules for the plumber. Oh, and I just broke my font. Oops. Anyways, you can see the kind of how they do it. Type this text, destination is MS Word, plumb to MS Word, start, word to doc, font. Email addresses get a new window, plumb start, et cetera, et cetera. So it can match email addresses and say do that. Okay, so let me restart my font file server. Let me delete this file and then restart my font server. And now fonts are back. Okay, so, oh yeah, so German engineering PNG. Anyone know what the photo is? I&#39;m guessing. Is that the LHC? No. That is the... They have a sense of humor Anyway Yeah, so hardware support it&#39;s actually got pretty good hardware support It&#39;s better or worse than the most? For the most? I&#39;ve heard rumors that it&#39;s better. Better? I don&#39;t know for sure, but it actually has hardware support. I can run it on my hardware. Most of the time, as long as I don&#39;t care about Wi-Fi, I can toss it on most hardware and it&#39;ll just work, at least with Visa drivers. So going into specifics, there are Wi-Fi drivers working on cards mostly Intel ones and I&#39;m using them right now to talk to that machine in Intel graphic native graphics drivers up to Haslo they were written in I believe a week part of it is that we don&#39;t care about 3d graphics so yeah yeah if you don&#39;t care about 3d all you really need to do is tell the graphics card hey I want this this area of memory to go onto the screen and then you draw onto that. So I&#39;m guessing this means that playtime does not in fact run Doom? Ah, I don&#39;t have any data for it. But it does have Doom. It shows it has Doom, it ships with it. You can&#39;t run Doom on the PC with the play? Is there a quick portion? Oh, that&#39;s not surprising. VMX, virtual machines. You can run OpenBSD on Plan 9 if you want. It&#39;s slow, but it exists. I see someone going, why? Well, if you happen to want a modern web browser that can do JavaScript, then you want to have an OS that can run a modern web browser that can do JavaScript. So for that you need virtualization. There are other reasons. too you want to be able to test your kernel without actually rebooting the machine and debugging it and so on but yeah having it uh having a virtual machine is super useful and it even runs ancient versions of windows i think um and the forwarding for uh for wi-fi bridging um that&#39;s done with mat daemon the mat daemon it for it bridges your ethernet for you don&#39;t ask me why it&#39;s called that but uh NVME is supported uh that was done in one weekend the uh SINAP uh his actual name is Friedman Gerald but uh I think everyone calls him SINAP because that&#39;s his nickname he is insane he is a machine for turning data spec sheets into code when I uh tested out his NVME drive and started using it, it didn&#39;t work. We started debugging it. I figured out why. The drive didn&#39;t conform to spec. Right, but wireless is probably worse. Wireless is... Specs versus write and go, right? Well, yes. Wireless is, well, complicated and also there&#39;s a ton of chipsets. TTM. So I&#39;m using that right now for this display. It works, hinting and all. It&#39;s independently developed. It&#39;s about 5,000 lines of code. It does a whole bunch of... Oh, sorry. Let me... Do I... Why is it not plumbing? Oh, it probably is plumbing to the other window. Yeah. But it&#39;s loading it. So, yeah, you can shape it. You can do... Why is that not plumbing? Let me just try one more time. Yes no maybe No, okay, let me figure out why that I might not have had have that file in that okay, maybe I forgot to copy that file I&#39;ll dig that into that later, but it does Asian text so Nicely laid out CWFS is the default file system it does snapshotting and lets you look through the history of your files so for example I can do local manifest dump that loads up that mounts the dump and then I can look at my files from 2018 or 2019 I don&#39;t know and yeah well they&#39;ve got support for it and here&#39;s my code way back then I didn&#39;t have that much code sitting on that But yeah, you can dig through the history of your files. By default, it takes a snapshot every night. And it&#39;s had this since probably about the 80s. Or early 90s, I guess. Git 9, that&#39;s my baby. So I&#39;ve implemented a complete, I&#39;ve done a complete Git implementation for Plan 9 from scratch. Lets you do all of the usual source code management stuff that you need. It&#39;s kind of fun. system based, does the init push pull export import. It&#39;s got a clean, easy to use, well, easier to use command line interface than upstream Git. I&#39;m not doing the clone. The upstream Git&#39;s UI is terrible, so let me do something good. To give you an idea of how the kind of things that you can do internally, here is the full implementation of Git merge. That&#39;s all. It&#39;s just a shell script. All it&#39;s doing is looking at which files which branch you want to well it starts by mounting your git file system decides which branches you want to merge then walks through the file system&#39;s view of the git file system&#39;s view of the data on that branch what you the git file system&#39;s view of the other branch and just use the uses the git3 command line to merge you don&#39;t need that much once you can actually access the data from your command line okay so cool but big yawn you&#39;ve already got all of these features why the hell do you care because you&#39;ve got units it does this what&#39;s the point of all this shit well the thing is that All the features that Unix has are nice, but the power of Plan 9 actually comes from something else that you can&#39;t get by adding features. The power of Plan 9 is, the essence of Plan 9 is 9P and namespaces. And that&#39;s essentially how you put the system together. So 9P is the Plan 9 file system protocol, and namespaces are essentially views into the files. Every window has its own namespace. So here is the full list of operations you can do in IP. There isn&#39;t anything else. All your communication with the system goes through this. The only things you use for, the only things you can, so all the system calls map to this or process management or namespace management. So you have your data access and manipulation, you have fork and you have mount and bind and basically that&#39;s and nsec which gives you the current time. Those are your system calls. Everything else is done through this. There is no other way to talk to the system. Now this is a network protocol and because the only way you talk to the system is through the network protocol everything becomes network transparent for free. are the way that you manage the view for all your programs. This is essentially the way that this is a view well a short snippet of the namespace for the current process or for a no longer current process. So you take the and this is from a remote log so mount term is your remote system. Mount term&#39;s devices are mounted over your local devices. in this case, which means that opening DevDraw on this machine or on that machine opens it on this machine. So a program that says I want to draw something to the screen over there gets redirected here for free. There&#39;s no code in that program that needs to know. Slash proc is slash proc. Hash devices like this are magical bootstrap things, so you can So you basically get a magical hash P device which you can bind into your namespace and start using it. Same with the pipes. RIO is your window system. And you kind of assemble any processes view of the system around it from these namespaces. But even then, this is cool, but it&#39;s not about 9P. Who cares that you&#39;re using specific protocol. It&#39;s about using unified mechanisms that you can interpose. And that&#39;s really the lesson that you can take from Plan 9 and port to other systems. Pick one way to do something and then once you&#39;ve picked that way of doing it, you can make sure that you can replace a component and put a layer in front of it and now you&#39;ve got a massive amount of flexibility. This is also why you can&#39;t take features from Plan 9 and move it to Unix. Because adding one more way to do things to Unix will not give you the ability to put a layer in between and intercept or rewrite or view all the operations that a program can do. So on Unix, I can&#39;t put in a interposer for dev draw or dev mouse or dev keyboard and rewrite or change the thing, change dev keyboard to say add in input methods for Japanese input easily, that has to be specially hooked into all the programs because there is no unified way of doing it. And all the features you want, unless you manage to guarantee that no one&#39;s using them anymore, well, then you just can&#39;t. So... Well, it&#39;s all, yeah, data level, yeah, but there&#39;s other things that people have. I mean, every, all the BSDs have a bunch of plain old ports now. Right? I mean, there&#39;s other user land layer tools that are out there that are important, including the C compiler. Sure. I mean, you can, yeah, you can definitely get an Ubuntu with the Plan 9 C. Yeah, well. Okay. So, the essence is really... I&#39;m not going to take the bait on that. Okay. You can, fine. You can get a free PSD with the Plan 9 C. Well, I mean, no, but I mean, I brought this up earlier, but like... And I know when everybody was all hot on PCC as replacement for GCC years ago, 15 years ago or whatever, there was a lot of talk about how Plan 9 C compiler was doing a lot of wonderful things that people would love to have. Yeah, and sure, that&#39;s true. There&#39;s a lot of good stuff in Plan 9 user space. But those are just features that you can port. I don&#39;t think that they&#39;re really the core idea of Plan 9. No, it&#39;s a fundamentally different operating system. I agree. Yeah, of course. Yeah. But anyway, that&#39;s my point. So, you know, GRP, so things that are happening in outside the client side world, gRPC, it sucks, but it&#39;s great. And Google is using it everywhere and gives you the same kind of, at least if you&#39;re at Google, it gives you the same kind of one interface to all your systems. Some places do the same thing with RINST and that kind of thing is, you know, really helpful. Docker, it&#39;s got the same kind of thing. It&#39;s a really nice way of managing your namespaces, putting things into little boxes. But it also sucks. So, 9P, I still think it&#39;s better than these guys because it&#39;s universal. So, Docker, gRPC, all the other tools on other systems are universal by convention. In other words, people kind of shut their eyes and go, no, no, no, no, nothing else exists. But on Planet... And 9P is actually the only way you can talk to the system. And the other nice thing is that it&#39;s actually implementable by you. So when I was working on, at my last job, we ended up using 9P for some firmware interfaces. And yeah, we didn&#39;t get the universality, but it&#39;s a nice way of actually connecting to firmware and modifying it. And it&#39;s, was something like 500 lines of code to implement. So, just to clarify, you&#39;re talking about 9P not on I&#39;m talking about 9P on well 9P universe being universal is on plan 9. 9P being implementable by humans that&#39;s all over the place. For work I was not using it on plan 9. That was sitting directly on a STM32 and experimental implementation 192 kilobytes of RAM etc etc and then we were talking to Linnae too. We were talking to that firmware through Linux using a user space implementational thing. Um, can any of the colleagues know what you&#39;re doing? Yes. Wow. So, uh, I think that&#39;s the one thing that made me go, this story guy has really weird ideas, but they always seem to work out. And then they just started letting me do what I wanted to do. Um, at one point, we were trying to figure out how to do RPC. within Linux ignoring the not to the firmware and I wasn&#39;t even even in the room when the CTO suggested we use 9p and what is GRCC sorry what is GRPC oh okay gRPC is Google&#39;s uh RPC protocol so uh uh yeah gRPC it&#39;s basically uh protobufs yeah okay it&#39;s a way of describing this service these messages and has these functions you can call them. Uh yeah. Oh yes, yeah it&#39;s actually kind of weird how 9P seems to become the traditional default implementation for connecting the native OSS file system with a virtualized machine&#39;s file system. Now to be fair, It&#39;s a very heavily extended 9P. So 9P is basically Ken&#39;s idea of, Ken Thompson&#39;s idea of, this is what a VFS should look like. And then, so it&#39;s got these many operations. 9P for virtual machines has got these many operations. And it&#39;s all the stat stuff, all of the mmap, et cetera, et cetera. But it&#39;s still there. So for example, you&#39;ve got slash net instead of sockets. So on Unix you have a whole bunch of special system calls for creating sockets. On Plan 9 you have netTCP clone which creates a new connection and then that gives you a night reading the clone file descriptor lets you control the connection also tells you okay so your data is sitting over here in the netTCP zero data. And that that you open that file and start doing I on that to do your TCP which is nice. As opposed to syscalls. As opposed to syscalls. Okay so isn&#39;t there a real problem with giving fine-grained control over syscalls then? There aren&#39;t that many syscalls. But. Right but so I need to give an application you know I need to talk TCP for anything all of a sudden. I&#39;m giving one syscall. It&#39;s a file so it&#39;s a permission base. Right, but I&#39;m giving away like everything. I&#39;m giving it a lot more less fine-grained control than I would with syscalls, right? Well, with... The assumption is that if you have limited syscalls, one syscall does a lot more than a unit system. One syscall lets you do more things, but you have the control to, you know, to basically allow open... TCP socket. If you don&#39;t want TCP sockets, don&#39;t put it into the process&#39;s namespace. Now at the same time, there&#39;s no firewall, so you can&#39;t say I&#39;m only allowing TCP on port 443, but that&#39;s an implementation issue, not a, or quality of implementation issue, not a fundamental limitation. What you could do, if you really wanted to, was write, well, I&#39;ll talk a little bit more about that in a second. It might even be the next slide. Okay, now, so this is actually, shell script that opens TCP connections and starts talking on IRC. What you&#39;re doing here is a whole bunch of file descriptor manipulation saying, you know, dial, well, start by figuring out who you&#39;re talking to. So the address is the second connection. Slash net is the network stack you happen to want to use. Do IRC and nickname. Do IRC will be your script that actually does IRC. And so you start by dialing it using NDBCS query which basically looks it up and then you basically run your command. There&#39;s nothing too special the only trickery here is that you need to actually keep the script running so that the files descriptors don&#39;t go away when the command disappears. You can do something vaguely like this on Linux except you can can&#39;t open net data you&#39;d need to write a special program that does TCP. This is manipulated entirely through the shell script. Now there is more. You can actually interpose your own network stuff. So SSH net is a program that takes your well that it&#39;s a file server. What it does is it takes the network stack that sorry it emulates a network stack but instead of doing working locally it tunnels it through TCP so this is a TCP sorry an SSH proxy that programs don&#39;t know about basically SOCKS tunn tap I guess is the closest script you&#39;d have on Unix and you can do SSH through that this is just namespaces and IP and if you wanted to restrict ports well I would do it through something like this where you&#39;d have a program that basically puts itself between the network stack and your program and says, no, no, no, no, no. You&#39;re trying to talk on port 444. You&#39;re only allowed 443. Goodbye. So there&#39;s more. If you want to use a, instead of network address translation, you can just mount someone else&#39;s network stack and put it on top of yours. So now you can just tunnel your network through it. Again, namespace is in 9p. You don&#39;t need any special support in the program if you don&#39;t need any special support in your operating system. All it is is mount basically. So Rio is doing the exact same thing except with dev draw. So dev draw is actually the entire screen and what Rio does is it says okay let me split that up into rectangles. Each program thinks it&#39;s got its full dev draw full screen. Rio just kind of creates a virtual one and splits it splits things out. It does the same with mouse and keyboard and multiplexes it between the windows that it&#39;s emulating so you can actually run Rio within Rio and it doesn&#39;t matter. Programs don&#39;t I well yeah it&#39;s a slight lie I say programs don&#39;t care there&#39;s extra information that Rio gives them like the window name and so on which you can set but for the most part it&#39;s the same dev draw same drawing protocol as anything else. And help, even this slide. So my script here, this is my slideshow program. I have a text editor that actually looks at the slide list and manipulates the text editor&#39;s contents of the window. So here is the entire slideshow program I&#39;m using here to present to you. So... So that gives you the whole 9P overview. Now what do you do with, so how do you actually put things together? Well, typically a Plan 9 machine, a Plan 9 network has several machines. You&#39;ve got a terminal, you&#39;ve got a CPU server, you&#39;ve got a file server, and you&#39;ve got an auth server. So, oops, wrong slide, wrong direction. So the terminal is just a dumb terminal, local device access. Draw term, which is what I&#39;m using to remote into that system. resources, hey I want that machine&#39;s keyboard, hey I want that machine&#39;s uh user list, hey I want that machine&#39;s uh file system and that machine&#39;s files. And then Factotum is basically your uh user uh like SSH agent. It&#39;s nothing too special. Um and that&#39;s basically your secret management and stuff. So basically you compose things into a network by gluing things together with namespaces. Uh seamless uh to remote resources it falls out of the whole model it come the way the way that you administer and use the system it basically comes for free with the unified model now of course this has a cost because everything is so general you can&#39;t really do special hacks like send file which assumes local file descriptors and so on the generality is The generality isn&#39;t free, but the composition is. Okay, so I&#39;m going to skip going through our CPU because I feel like we&#39;ve been taking long enough. Actually, I&#39;ll just show you roughly how long it is. This is the script that you actually use to remotely log into a machine. The core of it is really just mount. I&#39;ve been talking about namespaces and binds, basically all it does go to this machine, take this thing&#39;s devices, put them on top, and you&#39;re done. Cool. So that&#39;s that. Anyways, that&#39;s it. I hope you have enjoyed your bit of OS necrophilia. Yes. I believe that at some point in the past Pearl was supported with Plan 9 but we haven&#39;t had a smoke test with it in many years. So I&#39;m wondering if you have any information on the usability of either Pearl or other dynamic programming languages? There is Python that ships with the system. Really old Python? Yes. 2.5 something? Yes. There is a 2.7 that&#39;s been ported, but really Python&#39;s only around because people want mercurial, which I am working to kill. So the idea there is that we&#39;re hopefully going to just move that to ports and get rid of the base system Python. There is a Perl port from 2003, I think. And that is, I don&#39;t think it&#39;s been touched since. I would be interested in seeing someone update it, but yeah, most of it&#39;s just RC and There&#39;s Python shipped, but no one really seems to like it. Go is actually, it&#39;s not really a dynamic language, but it is supported and is ported. There is, oh, hmm? By the author? Yes, yes, I believe the author of, or I don&#39;t know if it is the author of Go, but there is definitely Go port that&#39;s actually can&#39;t be updated. And then there&#39;s an open file that&#39;s happened recently. Wow. Okay. For some reason, every time I look at the way you can edit the real environment, for some reason it reminds me of a small talk environment. It&#39;s dynamic, ever-changing. You can update it right there on the fly and the changes will apply more or less immediately. I mean, when they were developing Plan 9 and real, they look at small talk and say, hey, this is a pretty awesome idea. Let&#39;s do this. So this is actually not real. This is Acme which is the text editor. Rio is the window system around the editor. But if you want to, so the inspiration for the editor was not Smalltalk but it was overall which is Nicholas Wirt&#39;s or Wirt&#39;s system. Basically he he started doing the dynamic text stuff and Rob Pike kind of looked at it and went I like that I&#39;m stealing it. It does it does remind me a lot of Smalltalk. basically change an aspect of the environment. It takes place immediately and you just get marks using it. Yeah, so Oberon is really the place that that came from here. So, um, sorry to add on really quickly. Go ahead. Are there other languages available on PineLine besides the ones you mentioned, Perl and Python and Go and O-C? C? That&#39;s that it? My language is ported. There are a couple. Do I have ports on this system? I mean, I think I do. Uh, Meridan. Sorry, what was it again? Uh, Meridan, I&#39;ll type it actually. I&#39;ll just type it up here. Yeah, so that&#39;s my language. Meridan, yep. Oops. And here is... Okay, so not too much. There&#39;s a tickle port. And so... Oh, there is a squeak. Oh, there is a squeak. Huh? So it&#39;s still small talk? Yeah. So it&#39;s not a... There&#39;s a lab? You read those lab notes? Yeah, yeah. So there&#39;s a Fortran to C. For all those Fortran programmers, go. Go 1.4 which is used for bootstrapping and a wrapper around it that pulls in Go 1.4 and then builds in Go Bootstrap. There&#39;s Lua, there&#39;s Merdin, there&#39;s OCaml, there&#39;s Scheme, there&#39;s Squeak which is smalltalk, there&#39;s Tickle and then there&#39;s TinyScheme. The Perl port is not in this list. It does exist. It seems to Someone used it for porting Git actually fairly recently. So the upstream Git, not my re-implementation. Yeah. Did it run by Grayland with close week? Yes, I don&#39;t think it&#39;s... Oh yeah, new stuff. I think an early slideshow of Mix as a fork of Plan 9. Is that... That is a different Mix. Oh, is it? There is a fork of Plan 9 that is experimental. with scheduling so what Nix does is basically trying to it&#39;s plan 9 but with the idea of having a kernel core and application cores and yeah you&#39;re saying that&#39;s not the Nix that&#39;s not the probably not okay they are doing they were doing some interesting stuff where basically the idea is that you can have cores that the application only runs on top of and the system calls go to the kernel to CPU which is not going to affect scheduling. And the idea behind it was as CPUs start to have 64, 128 cores, you&#39;re going to have enough that all the busy applications can just consume enough core to themselves and don&#39;t need to be scheduled. So if something needs to happen, it&#39;s going to be super low latency. And that was coming out of the high performance computing world. So IBM, I think during that era, was doing a bunch of research on supercomputers with one line. Yes. First, I&#39;m very, I was, for a long time I was not into Windows 99 because it seemed like I needed to use a mouse. But now I see that it&#39;s very powerful to be able to click on things. So it&#39;s made me want to, it&#39;s made me bring it to, oh you want to click on the mouse? Yeah. No. So I&#39;m playing 99 because the mouse would be useful. But with Linux 99, maybe the mouse would be useful suddenly. Now I&#39;m wondering, um, Of course the issue is that not like all the software I use isn&#39;t going to work. It would very well, oh yeah. So I&#39;m wondering if there&#39;s an easier way to deal with this problem. Currently I have like one main computer and then anything that I can&#39;t, that I&#39;ve given up on porting to that computer, I run somewhere else in SSH. Yeah, but for example for a time I had it that, now I have the scanner working, but for a time I had it that I SSH&#39;d to another computer. I had a program like let&#39;s say I call it scanner, and that would log into another computer. So if I&#39;m doing that is there a better way to plan on doing that than doing the exact same thing? I mean you can SSH and do things directly like I just SSHed into my OpenBSD box. You can do SSHFS which mounts SSH. It&#39;s I mean you&#39;re still talking to a Unix system. So there&#39;s only so much you can do. So it&#39;s fuse support or? No, I mean it&#39;s SSH, it&#39;s 9P. It&#39;s not SSH, it&#39;s a different SSH client. Yeah, it&#39;s a different SSH client. It&#39;s Plan 9, everything&#39;s a server. Yeah. As opposed to everything&#39;s a client. Yeah, and basically, I mean, Plan 9, if you thought OpenBSD reinvented the realm was bad, Plan 9 kind of takes it to the next level. You know, we&#39;ve got our own SSH with our own SSH implementation. uh that was another synapse project i think it took a week or two and it&#39;s 1500 lines of code would would you or have you run a public box on the internet with plan nine uh i have not i might but there are public boxes i believe sdf uh there&#39;s also nine grid where basically there&#39;s a shared file server and someone&#39;s giving out free accounts to whoever asks I believe and Which which is the fork you using I&#39;m using nine front nine front yeah the front fell off What about I mean what I&#39;m actually most curious about is is I mean I know the origins and the devs were of the developers about the beginning are any of them still involved or is this just like Let me see if I can find the QA really quickly? Frequently question and answers. I didn&#39;t know this, I&#39;m going to get shot at it, I don&#39;t know if that was, I didn&#39;t know they did it. Yeah, so by the way, that gives you an attitude of the drill. Everyone knows about that format. Okay. Plan so section one plan nine is not for you just to emphasize it in case the start of my presentation was not enough This is not the fastest network I&#39;m tethered to my phone so Actually, why did plan nine&#39;s creators give up on plan nine? I can&#39;t read either. Yeah, I&#39;m trying. I&#39;m waiting for the pictures to load. There are pictures. The text itself is way too small. I see a contrast in colors. Yeah. So for the people that can&#39;t read, I was your pilot. Basically, the people that were working on Plan 9, Bell Labs died. They stopped getting a salary and they went on to work on other things. Mostly at Google. When they went to die at Google, yeah. Yeah. The preferred phrase, I believe, is went on display. Yeah. So basically, yeah. So Google is where bad folks go when they die. It&#39;s their way to fire and fry. The best recording tool Google has. To be fair, it&#39;s like Ken Thompson and Rob Pike working on Plan I, then when Google made the single video, yeah. And that&#39;s it. Yeah. Well, Ken is now fully, I believe fully retired. Yeah. Yeah, Ken is retired. I did see Ken though earlier this year at um, the Vintage Computer Fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the in plan nine I believe at the end of August. There&#39;s an inferno somewhere on the plan? I don&#39;t know. There&#39;s a port but it&#39;s not really updated. Yeah. So a port for what? It&#39;s an inferno the operating system yet. Yeah. Or the Pi. Yeah. So the Raspberry Pi was a interesting to watch happen mainly because the Raspberry Pi 4 is ridiculously complex. And the bug that really caught people for a long time, by the way feel free to just go talk amongst yourselves because at this point I&#39;m just telling stories. But basically what happened, the bug that really hung things up for a few weeks was the Raspberry Pi would work and then randomly some ethernet traffic would happen and all interrupts. everything would freeze for exactly 42 seconds and then it would resume which raspberry pi pi 4 it&#39;s not sharing the bus anymore with usb and everything else no it&#39;s got real internet so yeah so sitting there debugging trying to figure out everything that&#39;s going on uh getting well trying to get people at Broadcom to give some hints and so on and so forth and eventually they kind of after enough banging they figure out exactly what&#39;s happening if you walk off the end of executable executable memory you end up getting well the bus kind of goes wonky long enough for a hundred megahertz timer to tick over 32 bits which is 42 seconds now None of the memory accesses that they were doing were wrong. So they were looking over that with a fine-tooth comb. But it turned out that the memory had been mapped in the page tables with an executable bit. So what was happening was the CPU was going, okay, you&#39;re running along these instructions. Let me prefetch the next ones. And that fell off the end of the executable of valid memory. The bus kind of went, ah, my head&#39;s on fire and this the whole thing locked up for 42 seconds eventually timer wrapped around and everything started working again and it turned out that they had actually thought of this initial or the the reporting people had initially thought of this so synapse but there was a typo misread of the doc documentation I&#39;m not sure so he was saying it wrong bit on the page table so yeah so uh has has anyone or do you think will anyone be masochistic enough to try and port this to the RISC-V architecture? um compilers have to happen first but why not a compiler I could see somebody import it to this fine recently yeah I think yeah I think there was uh yeah Okay, so then it&#39;s possible. I think Richard Miller was doing some stuff around that. I&#39;m not sure. And Charles Forsyth is usually the compiler guy, so he might have that stuff too. It&#39;s probably buggy because nothing&#39;s really using it at the moment. But if it exists, the bugs can be fixed and someone can do a port. It&#39;s just a matter of someone wiggling fingers. I&#39;m intrigued by the point about Go. Now I&#39;m thinking, everyone seems to like Plan 9 and everyone seems to hate Go. What should we make of this? Nobody uses Plan 9. Nobody uses Go. I&#39;m sure that a lot of people will hate Plan 9 if they had to actually use it. You had a question about that? Did that actually work for different sized fonts in different windows? Uh yeah. Yeah, sorry. I probably should have been changing the fonts more, but uh it was a bit annoying to switch them around. So you- Yes, sir. We&#39;re talking a lot about the words and the fonts being clickable, but I think I- I guess I&#39;m worried that I can&#39;t tell what&#39;s clickable and what isn&#39;t. Like there&#39;s no- Everything&#39;s clickable. There&#39;s no like UI. What does that mean like? If you click on a word that does- correspond to what if you click on the word like your up in there like when you go past that oh uh let me see your uh i don&#39;t see your so let me just type it yeah sure okay so you can right click and nothing and it&#39;ll just search for the next one middle click will just do nothing you might be able to put rm in there oh rm will delete it ah sure uh It just seems like there&#39;s a lot of potential unintended consequences. It&#39;s like a terminal. It&#39;s not like a terminal. You could accidentally do something. I could accidentally do something. Yeah. All right. Okay, so we went over the languages that are available in Plan 9 or available for Plan 9. So let&#39;s get to the next slide. which is porting software to Plan 9, how easy or how difficult or how pulling and seeing is it to bring any kind of software over to Plan 9, whether it&#39;s Unix, Windows, Mac, whatever to Plan 9? Windows isn&#39;t happening. Well, I don&#39;t think it&#39;s happening. But like I guess like anything like, you know, maybe POSIX compliant. I mean, does Plan 9 have POSIX compliance in it? It has an integration layer, yes. Okay, so if I bring anything POSIX compliant to Plan 9, how easy would it be to just compile? than run in plan nine there&#39;s a chance it&#39;ll work um there it&#39;s it depends on how uh much or how much the surface area you use is so for example there&#39;s no m map i believe the closest that we do is if you try to m map something um a lot of places will do a read-only m map which you can just emulate by doing a read of the data and with malloc and then free it instead of m on map. There is, well none of the software that&#39;s been ported so far has needed pthreads, so there is no pthread support, at least not in 9front. There are patches floating around that implement pthreads, so if someone actually tried porting stuff, I would be happy to import pthreads into 9front. So I guess like anything that doesn&#39;t really need any kind of YP system calls and the other units or units like operating system should generally be okay to run I&#39;m not yeah yeah yeah all right so it&#39;s like if I wanted to do like a what I&#39;ll throw this one up in the air let&#39;s say like if I want to do like um Warwick tools for example oh I think we have those we have Warwick tools yeah uh again console again yeah yeah those are there all right what about like 5p code or 5p code got it all those two yeah so anything that&#39;s like I guess like yeah that does the wacky system calls or any kind of wacky libraries will run okay yeah if I can call them plan nine yeah now the one that we would like which no one&#39;s actually done yet is FFmpeg that one I believe there&#39;s a bunch of assembly that might need to be forwarded but it I think someone&#39;s started looking at it I&#39;m not sure what the status is I don&#39;t think they finished looking at it so on that note since you mentioned FFmpeg let&#39;s try the I wonder if that well first off you need the graphics yeah those are the hard part I think m player you probably want to write a new window back end yeah I mean let me call it from like from the command line because I know you can do that with with m player you can call it the command line say like m player run you know this file Yeah, and it launches it in a simple window. Not sure. Might be doable. The other thing that we&#39;d like to do is, you know, when, well, I mentioned that you can run VMs. I mentioned that X11 has recently been ported. The goal that I&#39;m hoping we can eventually get to is something kind of like Windows substitute for Linux, where basically you have the Linux kernel sitting beside the Pine9 kernel in an emulated environment, and whatever hooks are needed to make it not so using it yeah so i guess like you can almost be like it all sounds like what you&#39;re what you&#39;re saying is like calls like the the bsd jails yes kind of i guess kind of like have it sitting there in its own little container environment you call it necessary call it to run like an application and then just like once it&#39;s done just say okay go back yeah something like that and you have a question um yeah so i see like a big communication with the system it&#39;s based on a simple program right yeah so that It makes me wonder like uh then we reduce all the problem of this distributed systems via this network under 115. Yeah. How does how does this how it does might be handled in some different way or if it dies reconnect. Uh there is some uh there&#39;s a tool called AAN which is basically kind of like screen but for 9 or TMUX but for 9P instead of for proper sessions. Uh and that&#39;ll kind of transparently just stall the connection. and try reconnecting periodically until it starts working again. I believe it does some stuff to tell everything to redraw, reinitialize its stuff if you lose the connections, but I&#39;m not entirely sure. Yeah, but there&#39;s nothing magical in there. Are you using plan 9 port on the OpenBSD machine to talk to the 9 port machine or some other? Uh, drawterm. Okay. Uh, which is not plan 9 ported. It&#39;s basically uh um it&#39;s kind of a plain nine kernel in user space that has just enough in it to mount a nine P server and run the shell script that it uses to uh import the stuff from that machine and uh pull it and do the drawing. I&#39;m not going to go to a few utilities but nothing too but not too much. The main one I use is the plumber. So in my terminal I can right click on a URL or an email and open stuff up from there. Another way I see it is that it mounts the local file system to that namespace on that CPU server that&#39;s running in it. So you could open up an ASCII session with this bullet point and work on your local clients. Okay. Sam. Or play for your clients. Okay. Do you see Plan 9 like, you know, five or ten years from now being a sort of more adopted level or is it always going to be a kind of, you know, academic exercise? Sorry. I&#39;m actually slightly sick. That wasn&#39;t a sarcastic comment on purpose. It was just well-timed. Okay, so basically I don&#39;t see it taking off in any commercial sense. I think it&#39;s basically going to be same niche as haiku maybe you know people like the system they&#39;ll probably keep using it they might use it for personal stuff maybe one crazy company will try to do something but probably not unless I started and try and do it yeah but I mean you could hire the entire user base at client and still not have enough people to actually fund it or to staff a reasonable size company I think so I don&#39;t see it I see that a loneliness being a barrier it has been used commercially because we have someone who has used to work as a lawyer and he told me I don&#39;t know if it&#39;s true he said he ran his law firm there are a number of places there are no just not on talk he&#39;s on talk but this is not on talk so there are a lot of places have used it commercially in the past um or a lot um there are places that have used it commercially in the past uh for example there is a com a startup called Colrade which was built on that um there is so uh the Cisco PIX routers you might notice that PIX is Roman numerals P9 uh so they were based off of uh Plan 9. How? what does that mean uh they took plan the plan 9 code wanted platform yes yeah yeah that was plan uh at least initially i&#39;m guessing that at some point cisco rewrote it but that&#39;s a guess i thought i always thought the old uh older system oses back in those days ios and so on well pick based because they&#39;re all system five or psp So uh PIX was actually acquired by Cisco So yeah, I&#39;m guessing at some point after acquisition they kept the brand but so yeah, yeah Cool anyone else have yeah your comment on using I had to patch my terminal to make that work but Well, I don&#39;t know. Okay. There might actually be a patch floating around that&#39;s better than the one I have. I&#39;ll look around. Okay. No questions? Okay. Inputs Video: Plan_9_Not_dead,_Just_Resting,_by_Ori_Bernstein.mp4 This is an AI-generated summary of the video. Duration: 4626.367s (01:17:06) Audio stream (ffprobe): codec=aac, sample_rate=44100, channels=2, layout=stereo Output Artifacts Extracted WAV segments: audio_segments/seg_0000.wav  Local model snapshot: model/ This report: report.md Commands Executed Environment setup (one-time) uv venv --python 3.12 uv pip install --python .venv/bin/python torch torchaudio uv pip install --python .venv/bin/python &#34;nemo_toolkit[asr,tts] @ git&#43;https://github.com/NVIDIA/NeMo.git&#34; Model download (Hugging Face) mkdir -p model hf_home HF_HOME=&#34;$PWD/hf_home&#34; .venv/bin/hf download nvidia/canary-qwen-2.5b --cache-dir &#34;$PWD/hf_home&#34; --local-dir &#34;$PWD/model&#34; ffprobe ffprobe -v error -show_entries format=duration:stream=index,codec_type,codec_name,sample_rate,channels,channel_layout -of json /home/fff/Video/Plan_9_Not_dead,_Just_Resting,_by_Ori_Bernstein.mp4 ffmpeg (video  16kHz mono WAV segments) ffmpeg -y -i /home/fff/Video/Plan_9_Not_dead,_Just_Resting,_by_Ori_Bernstein.mp4 -vn -ac 1 -ar 16000 -c:a pcm_s16le -f segment -segment_time 30 -reset_timestamps 1 /home/fff/fpiorl/canary-qwen-2.5b-local/audio_segments/seg_%04d.wav Arguments Touched (Summary) mkdir arguments Argument Value Meaning -p (flag) Create directories if missing &lt;dirs&gt; model hf_home Directories created for snapshot &#43; cache uv / pip arguments Command Argument Value Meaning uv venv --python 3.12 Use Python 3.12 for the venv uv pip install --python .venv/bin/python Install packages into that venv uv pip install &lt;packages&gt; torch torchaudio PyTorch runtime dependencies uv pip install &lt;requirement&gt; nemo_toolkit[asr,tts] @ git&#43;https://github.com/NVIDIA/NeMo.git Install NeMo from GitHub with ASR&#43;TTS extras hf download arguments Argument Value Meaning HF_HOME $PWD/hf_home Env var that sets Hugging Face cache root repo_id nvidia/canary-qwen-2.5b Model repository to download --cache-dir $PWD/hf_home Where HF stores the snapshot cache --local-dir $PWD/model Where snapshot files are copied for local loading ffprobe arguments Argument Value Meaning -v error Only print errors -show_entries format=duration:stream=... Select duration &#43; stream fields to output -of json JSON output format &lt;input&gt; video path File to inspect ffmpeg arguments Argument Value Meaning -y (flag) Overwrite existing output files -i video path Input file -vn (flag) Disable video recording/output -ac 1 Downmix/set number of channels -ar 16000 Resample to target sample rate (Hz) -c:a pcm_s16le Encode audio as 16-bit PCM WAV -f segment Use the segment muxer (split into multiple files) -segment_time 30 Segment length in seconds -reset_timestamps 1 Reset timestamps per segment output pattern audio_segments/seg_%04d.wav Segment file naming template NeMo / SALM arguments Call Argument Value Meaning SALM.from_pretrained pretrained_model_name_or_path model/ Load weights/config from local folder SALM.from_pretrained cache_dir hf_home/ HF cache directory inside this folder SALM.from_pretrained local_files_only True Avoid downloading missing files from the internet model.generate prompts list of chat messages Batch of audio&#43;prompt inputs model.generate max_new_tokens 384 Max tokens generated per segment transcribe loop batch_size 16 Number of segments transcribed per generate() call Runtime Segments: 155 Total transcription time: 4370.3s (72.8 min) GPU: Intel HD Graphics 4400 Overall RTF (wall/audio): 0.94">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-02-04T15:33:12+01:00">
    <meta property="article:modified_time" content="2026-02-04T15:33:12+01:00">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Transcription of Plan 9, Not Dead, Just Resting, by Ori Bernstein">
  <meta name="twitter:description" content="N.B. This file was generated using artificial intelligence without a GPU.
Transcript Hello and welcome to BSD TV. This is a video of Ori Bernstein&#39;s October 2019 Nice Bug Meeting entitled Plan 9, Not Dead, Just Resting. Ori is someone I&#39;ve been running into at BSD CANS over the last few years. This current Westcoaster was nice enough to stop by the New York BSD Users Group, and for the true New York experience, we got a visit from the New York City Fire Department during his talk. Thankfully, it was a false alarm and Ori&#39;s talk was a success. attended with lots of new faces and engaging questions. Enjoy. I&#39;m going to be talking about Plan 9, as you can see. So what, a summary of what&#39;s happened to it, or what&#39;s happening with it, why you don&#39;t want to use it, why I use it anyways, and generally the state of the union. And of course, what people can learn from it, even if they&#39;re not using Plan 9. So, it&#39;s already been covered, but feel free to interrupt me if any If there are any questions, I&#39;d rather go off track or go and beat around the bush a little bit rather than just lose people or bore people. So just feel free to stop me and ask questions. So who am I? What do I do with Y Plan 9? So yes, I do have a Plan 9 laptop. It&#39;s that one over there. This one&#39;s actually running OpenBSD because I don&#39;t trust Plan 9&#39;s dual monitor output working on it. This one, but I am running this presentation remotely. over plan nine so you&#39;re getting the real deal um I use it regularly I actually write code on it I log into other systems and develop code from plan nine sometimes and yes that probably means there is something wrong with me I am definitely way too stuck um okay so why don&#39;t you want to use plan nine well it doesn&#39;t have the programs you want this uh came from the uh nine fans mailing list uh years and years ago and it details a typical new user&#39;s experience with Plan 9. Hi, I&#39;m Nita Plan 9. I&#39;m really excited to work with this new Linux. I hit some questions. How do I run X11? Where is Emacs? The code is weird. It doesn&#39;t look like GNU C at all. Do the Plan 9 people who wrote Plan 9 know at all about C? I tried to run Mozilla, but it didn&#39;t work. How come? You can tell this is an old post because it refers to Mozilla. Anyways, sorry, there is no X11 asterisk. Plan9 does its graphics through the dev draw device, keyboard FS, dev mouse, and real. I&#39;ll go into a bit more detail on that. So that star actually is because the slide went out of date this September. Someone actually got an old port of X11 working, and you can now basically run x programs on a Unix machine and have them display on Plan 9. Although amusingly enough, we got Chrome working before we got X-File. Yeah. So, yes. So Plan 9 has a Sage file? Yes. Can you do a Sage X-forwarding or a Sage? I don&#39;t believe so. I don&#39;t think that the X-forwarding channel has been implemented. So this is the Emacs methodology. And I&#39;m not joking. That is the actual man page. There is no Emacs. There is a man page for Emacs describing why they, that they don&#39;t, making it very clear that they do not like Emacs. And it was intentionally left out. There is VI. That&#39;s not the right VI. VI is a mix emulator. Someone has ported Vim. But I&#39;ve never actually tried using that. The web browsers are, to be blunt, crap. You have two web browsers shipped with the system. One is called Mozilla, one is called Apache. I will show them to you. They don&#39;t do Chrome, they don&#39;t do CSS, they don&#39;t do JavaScript. Does this use HTTPS? Yes, they do. Everything does HTTPS because the browsers don&#39;t actually do HTTP. You have WebFS that does HTTPS. HTTP for them. This is Mothra. Oh, I have not started WebFS on this thing. This is how Google works on PlanB. Well, it&#39;s pretty good. And it&#39;s actually kind of usable. TLS yeah that&#39;s the play all the in order to use the internet these days you need to use one of those garbage browsers like Firefox because the other things don&#39;t support TLS well they get a technology but this does yeah what is nice bug yeah sure oh yeah sorry to be totally off the bat about me but all right nice bug.org yeah That&#39;s actually not bad. Yeah. It&#39;s pretty good. Yeah. I can actually use that. It&#39;s a really simple HTML. It won&#39;t render anything. No, it will not. So it&#39;s actually a standards compliant browser. Relatively. Yeah. Yeah. DuckDuckGo. Okay. Oh wow. Yeah, I&#39;ve got a version that if you turn it on it&#39;ll it&#39;ll display this. Well, even no JavaScript version, right? Yeah, it goes to that process. Anyways, that&#39;s why I cut it off. So that&#39;s the web browser situation. You probably don&#39;t, that probably kills a lot of the usage. But, so that&#39;s what Plan 9 isn&#39;t. system that you can probably that you uh that runs your modern programs that you expect on Unix. Uh it&#39;s not POSIX it doesn&#39;t uh anything you want will probably be there&#39;s a POSIX emulation layer but it&#39;s not very good porting is a chore a lot of the time it&#39;s easier to run your own or to write your own. So it&#39;s not uh a Unixy system but it is a Unix-inspired minimalist distributed graphical text-oriented research operating system. That kind of covers most of it but it&#39;s a bit of a mouthful so let&#39;s break it down uh well the short summary slightly more facetiously is imagine all the good things you they told you were true about actually the good things they told you about unix were true well so first off it came from bell so it&#39;s got the same sort of design aesthetic as unix very minimalist very text oriented everything&#39;s designed around hierarchies of files But it&#39;s also uh yeah it&#39;s minimalist so much more minimalist than Unix. You&#39;ve got 50 system calls you&#39;ve got a very a much smaller number of programs uh the and things are kind of put together by assembling namespaces. Um it&#39;s Unix inspired so you know it&#39;s kind for many people it ends up kind of in the uncanny value of Unix. You know it&#39;s kind of like familiar but not really you know imagine your mom going for plastic surgery and coming back she looks kind of similar but you know there&#39;s a difference so distributed most of the time people use the word distributed to imply fault tolerance resilience and so on so I kind of hesitated using this word here but it is a distributed system the parts of it are not all on the same machine so draw term is that actually is what I&#39;m using to remote into that box. And the way it works is actually by, sorry I&#39;m a little bit sick, by pulling in parts of that system&#39;s namespace into this machine. It runs it, it&#39;s it, it&#39;s actually basically a stripped down emulated Plan 9 kernel running in user space that does the remote login. So it&#39;s kind of a crazy way to do it, but it works. And of course you&#39;re pulling you build the system by pulling in resources from other systems. I&#39;ll go into more detail on that later. Graphics. So you can&#39;t actually use Plan 9 effectively without it without graphics. The way that Plan 9 is designed you really want to have some sort of graphical terminal so that you can actually do things. The command line without graphics is extremely extremely variable it doesn&#39;t give you command line history it doesn&#39;t give you line editing so you can&#39;t actually mouse arrow back and forth edit the text you&#39;ve already typed it doesn&#39;t give you really anything because that&#39;s all be pushed into the Windows system so any any text is managed by the Windows system so for example you can see LS I have got that listed I can click back here and edit the scroll back and that&#39;s how you do the line editing if you want to let&#39;s pull up acid I don&#39;t care I&#39;m just getting some stuff into the history from outside the program and then quote quote quote pulls up history not easy yeah And you can see I&#39;m actually looking through dev text and I can find the previous lines. The code script is used for rerunning command line programs. I forgot that it actually looks for the prompt in the front for it so it filters out the... So the demo didn&#39;t quite do what I wanted, but you can actually look through all the command line history, poke at it, and that&#39;s done through the Windows system, not through the shell itself. Okay. So graphical, text-oriented. As you can see, there&#39;s not, everything&#39;s graphics, but all the graphics that it&#39;s showing right now are text. Everything&#39;s designed around manipulating text, splitting lines through text, and so on. And it&#39;s kind of designed around, well, the entire point of all the graphics is to make it easier to deal with text. It&#39;s also a research operating system. So the design of it is, part of the reason it&#39;s so simple is because it&#39;s a lot easier to mess with the system if you don&#39;t have tons and tons of his-ossified history. Uh, the- it comes with a bunch of research papers. Um, I- here I can actually make this lot bigger more easily. Uh, oops. Uh, we just type a new button. Type a new button. Oh yeah, yeah sure. You can type If I want to type a new window Yeah, so the Yeah, this is annoying I accidentally deleted my font size setting But you okay, so it comes with a bunch of research papers And so just to summarize the differences for graphics instead of Excel you&#39;ve got RIO which is the Windows system. Instead of the ship instead of born shell you&#39;ve got RC. RC is has a lot of useful features on top of born like having lists so you don&#39;t have to worry about word splitting killing your killing any script that has spaces. This is probably the most useful change in RC but overall it&#39;s a much more regular and less quirky syntax. The editors you get Sam and Acme instead of Emacs and Vim. For password management you get Factotum which is kind of the equivalent of SSH agent and SecStore on an off-server which actually securely stores your password. X11 is replaced with KeyboardFS, Draw, Mouse. NFS you get ExportFS over 9P. So that&#39;s the details of that. And a whole bunch of innovations that came out of research on Planet Earth. include UTF-8 which was apparently done in a diner in New Jersey. Are? Seriously? Yes. Yeah, seriously. Wow. Jersey represents. Yeah. Basically they kind of, the story is, there&#39;s a much better summary of it than I can give right now online, but in a minute or so they basically looked at what some standards body, I think IBM, was proposing, went, this isn&#39;t very good, let&#39;s do it better before they actually ratify the standard. So they did, and now we have UTF-8. The proc file system on Linux, that came from Plan 9 indirectly. Ported of compositing, which is the whole drawing with transparency and so on. Plan 9 did that first. The X11 X render extension explicitly mentions Plan 9 as the inspiration. Namespaces, like you&#39;d use in Docker, those came from Plan 9 communicating sequential processes so for example the communication model of Erlang and Go a lot of the initial implementation came from the Plan 9 research environment it&#39;s not the only place that that happened Tony Cor did not work on that on Plan 9 but it&#39;s one of the places where they really started experimenting with it and it looks like you&#39;re taking a picture so I will pause okay so cool and that&#39;s what Happened at Bell Labs. Bell Labs died. So What&#39;s happened since? Well There are a bunch of forks There is nine legacy or plan nine contract which is really a collection of patches nine Adam Harzi nine front Apero is next plan B inferno Probably more forks from users at this point maybe actually I don&#39;t think that&#39;s true I think there are more users than forks but I wouldn&#39;t bet on it anyways so quick summary of what these forks are there&#39;s nine legacy which is essentially a patch collection for the labs version of plan so they&#39;re not taking and really modifying it too much but they are collecting fixes new toys new hardware support and so on they&#39;re keeping the most important patches in the Git repo, the rest are just kind of apply as you like. Nine Atom is, again, Sigma, it&#39;s taking the Bell Labs stuff. They&#39;re not really touching the artwork. But they are just adding some hardware support to it. I&#39;m not sure what the current status of that is. The site seems to be down, but it&#39;s what these things come up and go down as stuff happens. And I believe Nine Atom is just one person. So there&#39;s Harvey. which is more modern modern uh more Unixy they&#39;re trying to actually make the uh POSIX environment good enough to run Unix programs without spending weeks porting them uh they&#39;re trying to port to move the compiler suite to GCC and clang they&#39;re trying to uh hook it up to I don&#39;t remember um I think they&#39;re trying to add the sanitizers all of the nice toys there&#39;s uh ACROS which is a research work that the University of Berkeley maintains and they&#39;re basically trying to do multi-core multi-core multi-core exploring a bunch of new ideas trying to figure out how to make multi-process a more native concept they&#39;re doing some neat stuff and pulling in a whole bunch of Linux eBICS as well I think they&#39;ve started using RCU for performance sake within the Plan 9 kernel instead of locking RCU is essentially read copy update which is block free multi-reader single writer concurrency I can go into more detail about that later if people have questions but I&#39;m not going to go too deep into that there&#39;s Inferno which is another it&#39;s not really a fork it&#39;s another interesting OS designed around Plan 9 but it&#39;s runnable on top of other operating systems too so if you want it Flang 9-ish system that can that you can run on top of Windows, Mac OS, Linux, Plat 9, and so on, as well as on bare metal, even down to machines with one megaram and no MMU. They do that. They&#39;ve written that in which is a JIT compiled language kind of like which runs on something vaguely like the JVM. It&#39;s a neat system. I haven&#39;t done too much with it, but yeah, so that exists. And then there&#39;s 9Front, which is the one that I use. It&#39;s actively maintained. It has great hardware support as far as these things go. So by great hardware support, I mean I can pick, say, ThinkPads and not spend years and years of digging to find some sort of support in hardware. Like I&#39;m using an X260. I&#39;ve got Wi-Fi. I&#39;ve got native resolution and so on. I think writing drivers using binary blobs native drivers so so they barely have enough users but they have developers who are writing yes reverse engineering or taking open source drivers uh the the hardware support is still not it&#39;s not giant but as far as so i&#39;m sorry what are the chips that&#39;s not the drill into this but i&#39;m just curious which groups support you know uh which chip oh wi-fi yeah wi-fi It&#39;s basically DINTL chips. DINTL? Yeah. I think it&#39;s IW. There are some ancient ones that are supported. I&#39;ve got a slide on that too. Oh, I should show you. So most of the Ninefront developers, or the main ones, are German. So of course I have to show you the German engineer. Oh yeah, I made a little click on that. And that, I said text-oriented. It knows there&#39;s, it&#39;s a J, it&#39;s Png. knows where the PNG is and it goes okay I should open that in the PNG viewer I thought it was a hard copy picture for the projection no no no so basically the plumber is a neat piece of another neat piece of engineering basically what you do is you send it messages it looks at the message and goes so what can I do with this text is it a C file in my current directory or a C file that I know about let me open it the editor. Is it a URL? Let me open it in the browser. Is it a message from the email program? Okay, I should show a notification that you&#39;ve received mail. And so on and so forth. So it&#39;s all text-based. You can, and you just, in this case, middle-click on it and it just says, okay, do your thing. Can you do it without a mouse? No, not really. There&#39;s a... file association it&#39;s it&#39;s actually looking at the file header it can yeah it&#39;s not just like oh this is a phg opens picture it&#39;s more than that right uh you can do that i believe it&#39;s you can basically attach any arbitrary script uh but you can do it in the os yes but it&#39;s at the level of the like the windowing system that recognizes it like it chums it into uh the file name it&#39;s not It&#39;s not within the editor. It&#39;s not and it&#39;s not like strictly like half specific is it? Like as long as it goes it goes through the policy and finds like policy says German engineering at the end of the chain so it says okay I found it open it. It&#39;s just like using magic words and operating systems. Like you literally modify it right there on the spot and just add new things to it. That&#39;s cool. Okay, here we go. So here are the rules for the plumber. Oh, and I just broke my font. Oops. Anyways, you can see the kind of how they do it. Type this text, destination is MS Word, plumb to MS Word, start, word to doc, font. Email addresses get a new window, plumb start, et cetera, et cetera. So it can match email addresses and say do that. Okay, so let me restart my font file server. Let me delete this file and then restart my font server. And now fonts are back. Okay, so, oh yeah, so German engineering PNG. Anyone know what the photo is? I&#39;m guessing. Is that the LHC? No. That is the... They have a sense of humor Anyway Yeah, so hardware support it&#39;s actually got pretty good hardware support It&#39;s better or worse than the most? For the most? I&#39;ve heard rumors that it&#39;s better. Better? I don&#39;t know for sure, but it actually has hardware support. I can run it on my hardware. Most of the time, as long as I don&#39;t care about Wi-Fi, I can toss it on most hardware and it&#39;ll just work, at least with Visa drivers. So going into specifics, there are Wi-Fi drivers working on cards mostly Intel ones and I&#39;m using them right now to talk to that machine in Intel graphic native graphics drivers up to Haslo they were written in I believe a week part of it is that we don&#39;t care about 3d graphics so yeah yeah if you don&#39;t care about 3d all you really need to do is tell the graphics card hey I want this this area of memory to go onto the screen and then you draw onto that. So I&#39;m guessing this means that playtime does not in fact run Doom? Ah, I don&#39;t have any data for it. But it does have Doom. It shows it has Doom, it ships with it. You can&#39;t run Doom on the PC with the play? Is there a quick portion? Oh, that&#39;s not surprising. VMX, virtual machines. You can run OpenBSD on Plan 9 if you want. It&#39;s slow, but it exists. I see someone going, why? Well, if you happen to want a modern web browser that can do JavaScript, then you want to have an OS that can run a modern web browser that can do JavaScript. So for that you need virtualization. There are other reasons. too you want to be able to test your kernel without actually rebooting the machine and debugging it and so on but yeah having it uh having a virtual machine is super useful and it even runs ancient versions of windows i think um and the forwarding for uh for wi-fi bridging um that&#39;s done with mat daemon the mat daemon it for it bridges your ethernet for you don&#39;t ask me why it&#39;s called that but uh NVME is supported uh that was done in one weekend the uh SINAP uh his actual name is Friedman Gerald but uh I think everyone calls him SINAP because that&#39;s his nickname he is insane he is a machine for turning data spec sheets into code when I uh tested out his NVME drive and started using it, it didn&#39;t work. We started debugging it. I figured out why. The drive didn&#39;t conform to spec. Right, but wireless is probably worse. Wireless is... Specs versus write and go, right? Well, yes. Wireless is, well, complicated and also there&#39;s a ton of chipsets. TTM. So I&#39;m using that right now for this display. It works, hinting and all. It&#39;s independently developed. It&#39;s about 5,000 lines of code. It does a whole bunch of... Oh, sorry. Let me... Do I... Why is it not plumbing? Oh, it probably is plumbing to the other window. Yeah. But it&#39;s loading it. So, yeah, you can shape it. You can do... Why is that not plumbing? Let me just try one more time. Yes no maybe No, okay, let me figure out why that I might not have had have that file in that okay, maybe I forgot to copy that file I&#39;ll dig that into that later, but it does Asian text so Nicely laid out CWFS is the default file system it does snapshotting and lets you look through the history of your files so for example I can do local manifest dump that loads up that mounts the dump and then I can look at my files from 2018 or 2019 I don&#39;t know and yeah well they&#39;ve got support for it and here&#39;s my code way back then I didn&#39;t have that much code sitting on that But yeah, you can dig through the history of your files. By default, it takes a snapshot every night. And it&#39;s had this since probably about the 80s. Or early 90s, I guess. Git 9, that&#39;s my baby. So I&#39;ve implemented a complete, I&#39;ve done a complete Git implementation for Plan 9 from scratch. Lets you do all of the usual source code management stuff that you need. It&#39;s kind of fun. system based, does the init push pull export import. It&#39;s got a clean, easy to use, well, easier to use command line interface than upstream Git. I&#39;m not doing the clone. The upstream Git&#39;s UI is terrible, so let me do something good. To give you an idea of how the kind of things that you can do internally, here is the full implementation of Git merge. That&#39;s all. It&#39;s just a shell script. All it&#39;s doing is looking at which files which branch you want to well it starts by mounting your git file system decides which branches you want to merge then walks through the file system&#39;s view of the git file system&#39;s view of the data on that branch what you the git file system&#39;s view of the other branch and just use the uses the git3 command line to merge you don&#39;t need that much once you can actually access the data from your command line okay so cool but big yawn you&#39;ve already got all of these features why the hell do you care because you&#39;ve got units it does this what&#39;s the point of all this shit well the thing is that All the features that Unix has are nice, but the power of Plan 9 actually comes from something else that you can&#39;t get by adding features. The power of Plan 9 is, the essence of Plan 9 is 9P and namespaces. And that&#39;s essentially how you put the system together. So 9P is the Plan 9 file system protocol, and namespaces are essentially views into the files. Every window has its own namespace. So here is the full list of operations you can do in IP. There isn&#39;t anything else. All your communication with the system goes through this. The only things you use for, the only things you can, so all the system calls map to this or process management or namespace management. So you have your data access and manipulation, you have fork and you have mount and bind and basically that&#39;s and nsec which gives you the current time. Those are your system calls. Everything else is done through this. There is no other way to talk to the system. Now this is a network protocol and because the only way you talk to the system is through the network protocol everything becomes network transparent for free. are the way that you manage the view for all your programs. This is essentially the way that this is a view well a short snippet of the namespace for the current process or for a no longer current process. So you take the and this is from a remote log so mount term is your remote system. Mount term&#39;s devices are mounted over your local devices. in this case, which means that opening DevDraw on this machine or on that machine opens it on this machine. So a program that says I want to draw something to the screen over there gets redirected here for free. There&#39;s no code in that program that needs to know. Slash proc is slash proc. Hash devices like this are magical bootstrap things, so you can So you basically get a magical hash P device which you can bind into your namespace and start using it. Same with the pipes. RIO is your window system. And you kind of assemble any processes view of the system around it from these namespaces. But even then, this is cool, but it&#39;s not about 9P. Who cares that you&#39;re using specific protocol. It&#39;s about using unified mechanisms that you can interpose. And that&#39;s really the lesson that you can take from Plan 9 and port to other systems. Pick one way to do something and then once you&#39;ve picked that way of doing it, you can make sure that you can replace a component and put a layer in front of it and now you&#39;ve got a massive amount of flexibility. This is also why you can&#39;t take features from Plan 9 and move it to Unix. Because adding one more way to do things to Unix will not give you the ability to put a layer in between and intercept or rewrite or view all the operations that a program can do. So on Unix, I can&#39;t put in a interposer for dev draw or dev mouse or dev keyboard and rewrite or change the thing, change dev keyboard to say add in input methods for Japanese input easily, that has to be specially hooked into all the programs because there is no unified way of doing it. And all the features you want, unless you manage to guarantee that no one&#39;s using them anymore, well, then you just can&#39;t. So... Well, it&#39;s all, yeah, data level, yeah, but there&#39;s other things that people have. I mean, every, all the BSDs have a bunch of plain old ports now. Right? I mean, there&#39;s other user land layer tools that are out there that are important, including the C compiler. Sure. I mean, you can, yeah, you can definitely get an Ubuntu with the Plan 9 C. Yeah, well. Okay. So, the essence is really... I&#39;m not going to take the bait on that. Okay. You can, fine. You can get a free PSD with the Plan 9 C. Well, I mean, no, but I mean, I brought this up earlier, but like... And I know when everybody was all hot on PCC as replacement for GCC years ago, 15 years ago or whatever, there was a lot of talk about how Plan 9 C compiler was doing a lot of wonderful things that people would love to have. Yeah, and sure, that&#39;s true. There&#39;s a lot of good stuff in Plan 9 user space. But those are just features that you can port. I don&#39;t think that they&#39;re really the core idea of Plan 9. No, it&#39;s a fundamentally different operating system. I agree. Yeah, of course. Yeah. But anyway, that&#39;s my point. So, you know, GRP, so things that are happening in outside the client side world, gRPC, it sucks, but it&#39;s great. And Google is using it everywhere and gives you the same kind of, at least if you&#39;re at Google, it gives you the same kind of one interface to all your systems. Some places do the same thing with RINST and that kind of thing is, you know, really helpful. Docker, it&#39;s got the same kind of thing. It&#39;s a really nice way of managing your namespaces, putting things into little boxes. But it also sucks. So, 9P, I still think it&#39;s better than these guys because it&#39;s universal. So, Docker, gRPC, all the other tools on other systems are universal by convention. In other words, people kind of shut their eyes and go, no, no, no, no, nothing else exists. But on Planet... And 9P is actually the only way you can talk to the system. And the other nice thing is that it&#39;s actually implementable by you. So when I was working on, at my last job, we ended up using 9P for some firmware interfaces. And yeah, we didn&#39;t get the universality, but it&#39;s a nice way of actually connecting to firmware and modifying it. And it&#39;s, was something like 500 lines of code to implement. So, just to clarify, you&#39;re talking about 9P not on I&#39;m talking about 9P on well 9P universe being universal is on plan 9. 9P being implementable by humans that&#39;s all over the place. For work I was not using it on plan 9. That was sitting directly on a STM32 and experimental implementation 192 kilobytes of RAM etc etc and then we were talking to Linnae too. We were talking to that firmware through Linux using a user space implementational thing. Um, can any of the colleagues know what you&#39;re doing? Yes. Wow. So, uh, I think that&#39;s the one thing that made me go, this story guy has really weird ideas, but they always seem to work out. And then they just started letting me do what I wanted to do. Um, at one point, we were trying to figure out how to do RPC. within Linux ignoring the not to the firmware and I wasn&#39;t even even in the room when the CTO suggested we use 9p and what is GRCC sorry what is GRPC oh okay gRPC is Google&#39;s uh RPC protocol so uh uh yeah gRPC it&#39;s basically uh protobufs yeah okay it&#39;s a way of describing this service these messages and has these functions you can call them. Uh yeah. Oh yes, yeah it&#39;s actually kind of weird how 9P seems to become the traditional default implementation for connecting the native OSS file system with a virtualized machine&#39;s file system. Now to be fair, It&#39;s a very heavily extended 9P. So 9P is basically Ken&#39;s idea of, Ken Thompson&#39;s idea of, this is what a VFS should look like. And then, so it&#39;s got these many operations. 9P for virtual machines has got these many operations. And it&#39;s all the stat stuff, all of the mmap, et cetera, et cetera. But it&#39;s still there. So for example, you&#39;ve got slash net instead of sockets. So on Unix you have a whole bunch of special system calls for creating sockets. On Plan 9 you have netTCP clone which creates a new connection and then that gives you a night reading the clone file descriptor lets you control the connection also tells you okay so your data is sitting over here in the netTCP zero data. And that that you open that file and start doing I on that to do your TCP which is nice. As opposed to syscalls. As opposed to syscalls. Okay so isn&#39;t there a real problem with giving fine-grained control over syscalls then? There aren&#39;t that many syscalls. But. Right but so I need to give an application you know I need to talk TCP for anything all of a sudden. I&#39;m giving one syscall. It&#39;s a file so it&#39;s a permission base. Right, but I&#39;m giving away like everything. I&#39;m giving it a lot more less fine-grained control than I would with syscalls, right? Well, with... The assumption is that if you have limited syscalls, one syscall does a lot more than a unit system. One syscall lets you do more things, but you have the control to, you know, to basically allow open... TCP socket. If you don&#39;t want TCP sockets, don&#39;t put it into the process&#39;s namespace. Now at the same time, there&#39;s no firewall, so you can&#39;t say I&#39;m only allowing TCP on port 443, but that&#39;s an implementation issue, not a, or quality of implementation issue, not a fundamental limitation. What you could do, if you really wanted to, was write, well, I&#39;ll talk a little bit more about that in a second. It might even be the next slide. Okay, now, so this is actually, shell script that opens TCP connections and starts talking on IRC. What you&#39;re doing here is a whole bunch of file descriptor manipulation saying, you know, dial, well, start by figuring out who you&#39;re talking to. So the address is the second connection. Slash net is the network stack you happen to want to use. Do IRC and nickname. Do IRC will be your script that actually does IRC. And so you start by dialing it using NDBCS query which basically looks it up and then you basically run your command. There&#39;s nothing too special the only trickery here is that you need to actually keep the script running so that the files descriptors don&#39;t go away when the command disappears. You can do something vaguely like this on Linux except you can can&#39;t open net data you&#39;d need to write a special program that does TCP. This is manipulated entirely through the shell script. Now there is more. You can actually interpose your own network stuff. So SSH net is a program that takes your well that it&#39;s a file server. What it does is it takes the network stack that sorry it emulates a network stack but instead of doing working locally it tunnels it through TCP so this is a TCP sorry an SSH proxy that programs don&#39;t know about basically SOCKS tunn tap I guess is the closest script you&#39;d have on Unix and you can do SSH through that this is just namespaces and IP and if you wanted to restrict ports well I would do it through something like this where you&#39;d have a program that basically puts itself between the network stack and your program and says, no, no, no, no, no. You&#39;re trying to talk on port 444. You&#39;re only allowed 443. Goodbye. So there&#39;s more. If you want to use a, instead of network address translation, you can just mount someone else&#39;s network stack and put it on top of yours. So now you can just tunnel your network through it. Again, namespace is in 9p. You don&#39;t need any special support in the program if you don&#39;t need any special support in your operating system. All it is is mount basically. So Rio is doing the exact same thing except with dev draw. So dev draw is actually the entire screen and what Rio does is it says okay let me split that up into rectangles. Each program thinks it&#39;s got its full dev draw full screen. Rio just kind of creates a virtual one and splits it splits things out. It does the same with mouse and keyboard and multiplexes it between the windows that it&#39;s emulating so you can actually run Rio within Rio and it doesn&#39;t matter. Programs don&#39;t I well yeah it&#39;s a slight lie I say programs don&#39;t care there&#39;s extra information that Rio gives them like the window name and so on which you can set but for the most part it&#39;s the same dev draw same drawing protocol as anything else. And help, even this slide. So my script here, this is my slideshow program. I have a text editor that actually looks at the slide list and manipulates the text editor&#39;s contents of the window. So here is the entire slideshow program I&#39;m using here to present to you. So... So that gives you the whole 9P overview. Now what do you do with, so how do you actually put things together? Well, typically a Plan 9 machine, a Plan 9 network has several machines. You&#39;ve got a terminal, you&#39;ve got a CPU server, you&#39;ve got a file server, and you&#39;ve got an auth server. So, oops, wrong slide, wrong direction. So the terminal is just a dumb terminal, local device access. Draw term, which is what I&#39;m using to remote into that system. resources, hey I want that machine&#39;s keyboard, hey I want that machine&#39;s uh user list, hey I want that machine&#39;s uh file system and that machine&#39;s files. And then Factotum is basically your uh user uh like SSH agent. It&#39;s nothing too special. Um and that&#39;s basically your secret management and stuff. So basically you compose things into a network by gluing things together with namespaces. Uh seamless uh to remote resources it falls out of the whole model it come the way the way that you administer and use the system it basically comes for free with the unified model now of course this has a cost because everything is so general you can&#39;t really do special hacks like send file which assumes local file descriptors and so on the generality is The generality isn&#39;t free, but the composition is. Okay, so I&#39;m going to skip going through our CPU because I feel like we&#39;ve been taking long enough. Actually, I&#39;ll just show you roughly how long it is. This is the script that you actually use to remotely log into a machine. The core of it is really just mount. I&#39;ve been talking about namespaces and binds, basically all it does go to this machine, take this thing&#39;s devices, put them on top, and you&#39;re done. Cool. So that&#39;s that. Anyways, that&#39;s it. I hope you have enjoyed your bit of OS necrophilia. Yes. I believe that at some point in the past Pearl was supported with Plan 9 but we haven&#39;t had a smoke test with it in many years. So I&#39;m wondering if you have any information on the usability of either Pearl or other dynamic programming languages? There is Python that ships with the system. Really old Python? Yes. 2.5 something? Yes. There is a 2.7 that&#39;s been ported, but really Python&#39;s only around because people want mercurial, which I am working to kill. So the idea there is that we&#39;re hopefully going to just move that to ports and get rid of the base system Python. There is a Perl port from 2003, I think. And that is, I don&#39;t think it&#39;s been touched since. I would be interested in seeing someone update it, but yeah, most of it&#39;s just RC and There&#39;s Python shipped, but no one really seems to like it. Go is actually, it&#39;s not really a dynamic language, but it is supported and is ported. There is, oh, hmm? By the author? Yes, yes, I believe the author of, or I don&#39;t know if it is the author of Go, but there is definitely Go port that&#39;s actually can&#39;t be updated. And then there&#39;s an open file that&#39;s happened recently. Wow. Okay. For some reason, every time I look at the way you can edit the real environment, for some reason it reminds me of a small talk environment. It&#39;s dynamic, ever-changing. You can update it right there on the fly and the changes will apply more or less immediately. I mean, when they were developing Plan 9 and real, they look at small talk and say, hey, this is a pretty awesome idea. Let&#39;s do this. So this is actually not real. This is Acme which is the text editor. Rio is the window system around the editor. But if you want to, so the inspiration for the editor was not Smalltalk but it was overall which is Nicholas Wirt&#39;s or Wirt&#39;s system. Basically he he started doing the dynamic text stuff and Rob Pike kind of looked at it and went I like that I&#39;m stealing it. It does it does remind me a lot of Smalltalk. basically change an aspect of the environment. It takes place immediately and you just get marks using it. Yeah, so Oberon is really the place that that came from here. So, um, sorry to add on really quickly. Go ahead. Are there other languages available on PineLine besides the ones you mentioned, Perl and Python and Go and O-C? C? That&#39;s that it? My language is ported. There are a couple. Do I have ports on this system? I mean, I think I do. Uh, Meridan. Sorry, what was it again? Uh, Meridan, I&#39;ll type it actually. I&#39;ll just type it up here. Yeah, so that&#39;s my language. Meridan, yep. Oops. And here is... Okay, so not too much. There&#39;s a tickle port. And so... Oh, there is a squeak. Oh, there is a squeak. Huh? So it&#39;s still small talk? Yeah. So it&#39;s not a... There&#39;s a lab? You read those lab notes? Yeah, yeah. So there&#39;s a Fortran to C. For all those Fortran programmers, go. Go 1.4 which is used for bootstrapping and a wrapper around it that pulls in Go 1.4 and then builds in Go Bootstrap. There&#39;s Lua, there&#39;s Merdin, there&#39;s OCaml, there&#39;s Scheme, there&#39;s Squeak which is smalltalk, there&#39;s Tickle and then there&#39;s TinyScheme. The Perl port is not in this list. It does exist. It seems to Someone used it for porting Git actually fairly recently. So the upstream Git, not my re-implementation. Yeah. Did it run by Grayland with close week? Yes, I don&#39;t think it&#39;s... Oh yeah, new stuff. I think an early slideshow of Mix as a fork of Plan 9. Is that... That is a different Mix. Oh, is it? There is a fork of Plan 9 that is experimental. with scheduling so what Nix does is basically trying to it&#39;s plan 9 but with the idea of having a kernel core and application cores and yeah you&#39;re saying that&#39;s not the Nix that&#39;s not the probably not okay they are doing they were doing some interesting stuff where basically the idea is that you can have cores that the application only runs on top of and the system calls go to the kernel to CPU which is not going to affect scheduling. And the idea behind it was as CPUs start to have 64, 128 cores, you&#39;re going to have enough that all the busy applications can just consume enough core to themselves and don&#39;t need to be scheduled. So if something needs to happen, it&#39;s going to be super low latency. And that was coming out of the high performance computing world. So IBM, I think during that era, was doing a bunch of research on supercomputers with one line. Yes. First, I&#39;m very, I was, for a long time I was not into Windows 99 because it seemed like I needed to use a mouse. But now I see that it&#39;s very powerful to be able to click on things. So it&#39;s made me want to, it&#39;s made me bring it to, oh you want to click on the mouse? Yeah. No. So I&#39;m playing 99 because the mouse would be useful. But with Linux 99, maybe the mouse would be useful suddenly. Now I&#39;m wondering, um, Of course the issue is that not like all the software I use isn&#39;t going to work. It would very well, oh yeah. So I&#39;m wondering if there&#39;s an easier way to deal with this problem. Currently I have like one main computer and then anything that I can&#39;t, that I&#39;ve given up on porting to that computer, I run somewhere else in SSH. Yeah, but for example for a time I had it that, now I have the scanner working, but for a time I had it that I SSH&#39;d to another computer. I had a program like let&#39;s say I call it scanner, and that would log into another computer. So if I&#39;m doing that is there a better way to plan on doing that than doing the exact same thing? I mean you can SSH and do things directly like I just SSHed into my OpenBSD box. You can do SSHFS which mounts SSH. It&#39;s I mean you&#39;re still talking to a Unix system. So there&#39;s only so much you can do. So it&#39;s fuse support or? No, I mean it&#39;s SSH, it&#39;s 9P. It&#39;s not SSH, it&#39;s a different SSH client. Yeah, it&#39;s a different SSH client. It&#39;s Plan 9, everything&#39;s a server. Yeah. As opposed to everything&#39;s a client. Yeah, and basically, I mean, Plan 9, if you thought OpenBSD reinvented the realm was bad, Plan 9 kind of takes it to the next level. You know, we&#39;ve got our own SSH with our own SSH implementation. uh that was another synapse project i think it took a week or two and it&#39;s 1500 lines of code would would you or have you run a public box on the internet with plan nine uh i have not i might but there are public boxes i believe sdf uh there&#39;s also nine grid where basically there&#39;s a shared file server and someone&#39;s giving out free accounts to whoever asks I believe and Which which is the fork you using I&#39;m using nine front nine front yeah the front fell off What about I mean what I&#39;m actually most curious about is is I mean I know the origins and the devs were of the developers about the beginning are any of them still involved or is this just like Let me see if I can find the QA really quickly? Frequently question and answers. I didn&#39;t know this, I&#39;m going to get shot at it, I don&#39;t know if that was, I didn&#39;t know they did it. Yeah, so by the way, that gives you an attitude of the drill. Everyone knows about that format. Okay. Plan so section one plan nine is not for you just to emphasize it in case the start of my presentation was not enough This is not the fastest network I&#39;m tethered to my phone so Actually, why did plan nine&#39;s creators give up on plan nine? I can&#39;t read either. Yeah, I&#39;m trying. I&#39;m waiting for the pictures to load. There are pictures. The text itself is way too small. I see a contrast in colors. Yeah. So for the people that can&#39;t read, I was your pilot. Basically, the people that were working on Plan 9, Bell Labs died. They stopped getting a salary and they went on to work on other things. Mostly at Google. When they went to die at Google, yeah. Yeah. The preferred phrase, I believe, is went on display. Yeah. So basically, yeah. So Google is where bad folks go when they die. It&#39;s their way to fire and fry. The best recording tool Google has. To be fair, it&#39;s like Ken Thompson and Rob Pike working on Plan I, then when Google made the single video, yeah. And that&#39;s it. Yeah. Well, Ken is now fully, I believe fully retired. Yeah. Yeah, Ken is retired. I did see Ken though earlier this year at um, the Vintage Computer Fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the in plan nine I believe at the end of August. There&#39;s an inferno somewhere on the plan? I don&#39;t know. There&#39;s a port but it&#39;s not really updated. Yeah. So a port for what? It&#39;s an inferno the operating system yet. Yeah. Or the Pi. Yeah. So the Raspberry Pi was a interesting to watch happen mainly because the Raspberry Pi 4 is ridiculously complex. And the bug that really caught people for a long time, by the way feel free to just go talk amongst yourselves because at this point I&#39;m just telling stories. But basically what happened, the bug that really hung things up for a few weeks was the Raspberry Pi would work and then randomly some ethernet traffic would happen and all interrupts. everything would freeze for exactly 42 seconds and then it would resume which raspberry pi pi 4 it&#39;s not sharing the bus anymore with usb and everything else no it&#39;s got real internet so yeah so sitting there debugging trying to figure out everything that&#39;s going on uh getting well trying to get people at Broadcom to give some hints and so on and so forth and eventually they kind of after enough banging they figure out exactly what&#39;s happening if you walk off the end of executable executable memory you end up getting well the bus kind of goes wonky long enough for a hundred megahertz timer to tick over 32 bits which is 42 seconds now None of the memory accesses that they were doing were wrong. So they were looking over that with a fine-tooth comb. But it turned out that the memory had been mapped in the page tables with an executable bit. So what was happening was the CPU was going, okay, you&#39;re running along these instructions. Let me prefetch the next ones. And that fell off the end of the executable of valid memory. The bus kind of went, ah, my head&#39;s on fire and this the whole thing locked up for 42 seconds eventually timer wrapped around and everything started working again and it turned out that they had actually thought of this initial or the the reporting people had initially thought of this so synapse but there was a typo misread of the doc documentation I&#39;m not sure so he was saying it wrong bit on the page table so yeah so uh has has anyone or do you think will anyone be masochistic enough to try and port this to the RISC-V architecture? um compilers have to happen first but why not a compiler I could see somebody import it to this fine recently yeah I think yeah I think there was uh yeah Okay, so then it&#39;s possible. I think Richard Miller was doing some stuff around that. I&#39;m not sure. And Charles Forsyth is usually the compiler guy, so he might have that stuff too. It&#39;s probably buggy because nothing&#39;s really using it at the moment. But if it exists, the bugs can be fixed and someone can do a port. It&#39;s just a matter of someone wiggling fingers. I&#39;m intrigued by the point about Go. Now I&#39;m thinking, everyone seems to like Plan 9 and everyone seems to hate Go. What should we make of this? Nobody uses Plan 9. Nobody uses Go. I&#39;m sure that a lot of people will hate Plan 9 if they had to actually use it. You had a question about that? Did that actually work for different sized fonts in different windows? Uh yeah. Yeah, sorry. I probably should have been changing the fonts more, but uh it was a bit annoying to switch them around. So you- Yes, sir. We&#39;re talking a lot about the words and the fonts being clickable, but I think I- I guess I&#39;m worried that I can&#39;t tell what&#39;s clickable and what isn&#39;t. Like there&#39;s no- Everything&#39;s clickable. There&#39;s no like UI. What does that mean like? If you click on a word that does- correspond to what if you click on the word like your up in there like when you go past that oh uh let me see your uh i don&#39;t see your so let me just type it yeah sure okay so you can right click and nothing and it&#39;ll just search for the next one middle click will just do nothing you might be able to put rm in there oh rm will delete it ah sure uh It just seems like there&#39;s a lot of potential unintended consequences. It&#39;s like a terminal. It&#39;s not like a terminal. You could accidentally do something. I could accidentally do something. Yeah. All right. Okay, so we went over the languages that are available in Plan 9 or available for Plan 9. So let&#39;s get to the next slide. which is porting software to Plan 9, how easy or how difficult or how pulling and seeing is it to bring any kind of software over to Plan 9, whether it&#39;s Unix, Windows, Mac, whatever to Plan 9? Windows isn&#39;t happening. Well, I don&#39;t think it&#39;s happening. But like I guess like anything like, you know, maybe POSIX compliant. I mean, does Plan 9 have POSIX compliance in it? It has an integration layer, yes. Okay, so if I bring anything POSIX compliant to Plan 9, how easy would it be to just compile? than run in plan nine there&#39;s a chance it&#39;ll work um there it&#39;s it depends on how uh much or how much the surface area you use is so for example there&#39;s no m map i believe the closest that we do is if you try to m map something um a lot of places will do a read-only m map which you can just emulate by doing a read of the data and with malloc and then free it instead of m on map. There is, well none of the software that&#39;s been ported so far has needed pthreads, so there is no pthread support, at least not in 9front. There are patches floating around that implement pthreads, so if someone actually tried porting stuff, I would be happy to import pthreads into 9front. So I guess like anything that doesn&#39;t really need any kind of YP system calls and the other units or units like operating system should generally be okay to run I&#39;m not yeah yeah yeah all right so it&#39;s like if I wanted to do like a what I&#39;ll throw this one up in the air let&#39;s say like if I want to do like um Warwick tools for example oh I think we have those we have Warwick tools yeah uh again console again yeah yeah those are there all right what about like 5p code or 5p code got it all those two yeah so anything that&#39;s like I guess like yeah that does the wacky system calls or any kind of wacky libraries will run okay yeah if I can call them plan nine yeah now the one that we would like which no one&#39;s actually done yet is FFmpeg that one I believe there&#39;s a bunch of assembly that might need to be forwarded but it I think someone&#39;s started looking at it I&#39;m not sure what the status is I don&#39;t think they finished looking at it so on that note since you mentioned FFmpeg let&#39;s try the I wonder if that well first off you need the graphics yeah those are the hard part I think m player you probably want to write a new window back end yeah I mean let me call it from like from the command line because I know you can do that with with m player you can call it the command line say like m player run you know this file Yeah, and it launches it in a simple window. Not sure. Might be doable. The other thing that we&#39;d like to do is, you know, when, well, I mentioned that you can run VMs. I mentioned that X11 has recently been ported. The goal that I&#39;m hoping we can eventually get to is something kind of like Windows substitute for Linux, where basically you have the Linux kernel sitting beside the Pine9 kernel in an emulated environment, and whatever hooks are needed to make it not so using it yeah so i guess like you can almost be like it all sounds like what you&#39;re what you&#39;re saying is like calls like the the bsd jails yes kind of i guess kind of like have it sitting there in its own little container environment you call it necessary call it to run like an application and then just like once it&#39;s done just say okay go back yeah something like that and you have a question um yeah so i see like a big communication with the system it&#39;s based on a simple program right yeah so that It makes me wonder like uh then we reduce all the problem of this distributed systems via this network under 115. Yeah. How does how does this how it does might be handled in some different way or if it dies reconnect. Uh there is some uh there&#39;s a tool called AAN which is basically kind of like screen but for 9 or TMUX but for 9P instead of for proper sessions. Uh and that&#39;ll kind of transparently just stall the connection. and try reconnecting periodically until it starts working again. I believe it does some stuff to tell everything to redraw, reinitialize its stuff if you lose the connections, but I&#39;m not entirely sure. Yeah, but there&#39;s nothing magical in there. Are you using plan 9 port on the OpenBSD machine to talk to the 9 port machine or some other? Uh, drawterm. Okay. Uh, which is not plan 9 ported. It&#39;s basically uh um it&#39;s kind of a plain nine kernel in user space that has just enough in it to mount a nine P server and run the shell script that it uses to uh import the stuff from that machine and uh pull it and do the drawing. I&#39;m not going to go to a few utilities but nothing too but not too much. The main one I use is the plumber. So in my terminal I can right click on a URL or an email and open stuff up from there. Another way I see it is that it mounts the local file system to that namespace on that CPU server that&#39;s running in it. So you could open up an ASCII session with this bullet point and work on your local clients. Okay. Sam. Or play for your clients. Okay. Do you see Plan 9 like, you know, five or ten years from now being a sort of more adopted level or is it always going to be a kind of, you know, academic exercise? Sorry. I&#39;m actually slightly sick. That wasn&#39;t a sarcastic comment on purpose. It was just well-timed. Okay, so basically I don&#39;t see it taking off in any commercial sense. I think it&#39;s basically going to be same niche as haiku maybe you know people like the system they&#39;ll probably keep using it they might use it for personal stuff maybe one crazy company will try to do something but probably not unless I started and try and do it yeah but I mean you could hire the entire user base at client and still not have enough people to actually fund it or to staff a reasonable size company I think so I don&#39;t see it I see that a loneliness being a barrier it has been used commercially because we have someone who has used to work as a lawyer and he told me I don&#39;t know if it&#39;s true he said he ran his law firm there are a number of places there are no just not on talk he&#39;s on talk but this is not on talk so there are a lot of places have used it commercially in the past um or a lot um there are places that have used it commercially in the past uh for example there is a com a startup called Colrade which was built on that um there is so uh the Cisco PIX routers you might notice that PIX is Roman numerals P9 uh so they were based off of uh Plan 9. How? what does that mean uh they took plan the plan 9 code wanted platform yes yeah yeah that was plan uh at least initially i&#39;m guessing that at some point cisco rewrote it but that&#39;s a guess i thought i always thought the old uh older system oses back in those days ios and so on well pick based because they&#39;re all system five or psp So uh PIX was actually acquired by Cisco So yeah, I&#39;m guessing at some point after acquisition they kept the brand but so yeah, yeah Cool anyone else have yeah your comment on using I had to patch my terminal to make that work but Well, I don&#39;t know. Okay. There might actually be a patch floating around that&#39;s better than the one I have. I&#39;ll look around. Okay. No questions? Okay. Inputs Video: Plan_9_Not_dead,_Just_Resting,_by_Ori_Bernstein.mp4 This is an AI-generated summary of the video. Duration: 4626.367s (01:17:06) Audio stream (ffprobe): codec=aac, sample_rate=44100, channels=2, layout=stereo Output Artifacts Extracted WAV segments: audio_segments/seg_0000.wav  Local model snapshot: model/ This report: report.md Commands Executed Environment setup (one-time) uv venv --python 3.12 uv pip install --python .venv/bin/python torch torchaudio uv pip install --python .venv/bin/python &#34;nemo_toolkit[asr,tts] @ git&#43;https://github.com/NVIDIA/NeMo.git&#34; Model download (Hugging Face) mkdir -p model hf_home HF_HOME=&#34;$PWD/hf_home&#34; .venv/bin/hf download nvidia/canary-qwen-2.5b --cache-dir &#34;$PWD/hf_home&#34; --local-dir &#34;$PWD/model&#34; ffprobe ffprobe -v error -show_entries format=duration:stream=index,codec_type,codec_name,sample_rate,channels,channel_layout -of json /home/fff/Video/Plan_9_Not_dead,_Just_Resting,_by_Ori_Bernstein.mp4 ffmpeg (video  16kHz mono WAV segments) ffmpeg -y -i /home/fff/Video/Plan_9_Not_dead,_Just_Resting,_by_Ori_Bernstein.mp4 -vn -ac 1 -ar 16000 -c:a pcm_s16le -f segment -segment_time 30 -reset_timestamps 1 /home/fff/fpiorl/canary-qwen-2.5b-local/audio_segments/seg_%04d.wav Arguments Touched (Summary) mkdir arguments Argument Value Meaning -p (flag) Create directories if missing &lt;dirs&gt; model hf_home Directories created for snapshot &#43; cache uv / pip arguments Command Argument Value Meaning uv venv --python 3.12 Use Python 3.12 for the venv uv pip install --python .venv/bin/python Install packages into that venv uv pip install &lt;packages&gt; torch torchaudio PyTorch runtime dependencies uv pip install &lt;requirement&gt; nemo_toolkit[asr,tts] @ git&#43;https://github.com/NVIDIA/NeMo.git Install NeMo from GitHub with ASR&#43;TTS extras hf download arguments Argument Value Meaning HF_HOME $PWD/hf_home Env var that sets Hugging Face cache root repo_id nvidia/canary-qwen-2.5b Model repository to download --cache-dir $PWD/hf_home Where HF stores the snapshot cache --local-dir $PWD/model Where snapshot files are copied for local loading ffprobe arguments Argument Value Meaning -v error Only print errors -show_entries format=duration:stream=... Select duration &#43; stream fields to output -of json JSON output format &lt;input&gt; video path File to inspect ffmpeg arguments Argument Value Meaning -y (flag) Overwrite existing output files -i video path Input file -vn (flag) Disable video recording/output -ac 1 Downmix/set number of channels -ar 16000 Resample to target sample rate (Hz) -c:a pcm_s16le Encode audio as 16-bit PCM WAV -f segment Use the segment muxer (split into multiple files) -segment_time 30 Segment length in seconds -reset_timestamps 1 Reset timestamps per segment output pattern audio_segments/seg_%04d.wav Segment file naming template NeMo / SALM arguments Call Argument Value Meaning SALM.from_pretrained pretrained_model_name_or_path model/ Load weights/config from local folder SALM.from_pretrained cache_dir hf_home/ HF cache directory inside this folder SALM.from_pretrained local_files_only True Avoid downloading missing files from the internet model.generate prompts list of chat messages Batch of audio&#43;prompt inputs model.generate max_new_tokens 384 Max tokens generated per segment transcribe loop batch_size 16 Number of segments transcribed per generate() call Runtime Segments: 155 Total transcription time: 4370.3s (72.8 min) GPU: Intel HD Graphics 4400 Overall RTF (wall/audio): 0.94">

      <link rel="stylesheet" href="/css/mermaid.min.7931145f59079e05cc4ce16bdd84bc1374bb48b6fdf0e658ff5b4dba561b63ae.css" integrity="sha256-eTEUX1kHngXMTOFr3YS8E3S7SLb98OZY/1tNulYbY64=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css" integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H&#43;ZeT/jBpieRZ8=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/bundle.min.b18186833defff447f41ab504144af5b6a1ec8326075b47f4496af588f2f1f51.css" integrity="sha256-sYGGgz3v/0R/QatQQUSvW2oeyDJgdbR/RJavWI8vH1E=" crossorigin="anonymous">

      <script src="/js/bundle.25960c81b823e5675d08f82b271678532ee24e5eca99d6b8535c48b74cb0b3a3.js" integrity="sha256-JZYMgbgj5WddCPgrJxZ4Uy7iTl7Kmda4U1xIt0yws6M=" crossorigin="anonymous"></script><script defer src="/js/search/flexsearch.compact.3928d3d2172bc0b5f75d9458fb9255f0befce1c7239ba6e5d2c58ed4b82c2073.js" integrity="sha256-OSjT0hcrwLX3XZRY&#43;5JV8L784ccjm6bl0sWO1LgsIHM="></script>
<script defer src="/js/search/search.849f08ee09878c5f7699a215d7f76df1ab672a5015c0d61d48a6c693949d5a44.js" integrity="sha256-hJ8I7gmHjF92maIV1/dt8atnKlAVwNYdSKbGk5SdWkQ="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="https://fpiorl.github.io/" style="color: inherit;">fpiorlblog</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="https://fpiorl.github.io/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="https://fpiorl.github.io/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp&nbsp</span>
</ol>
<h1>Transcription of Plan 9, Not Dead, Just Resting, by Ori Bernstein</h1><time class="dim" datetime="2026-02-04T15:33:12&#43;01:00">February 4, 2026</time></div>
  <section class="page-section"><p>N.B.
This file was generated using artificial intelligence without a GPU.</p>
<h2 id="transcript">Transcript</h2>
<div class="rtwt-transcript">Hello and welcome to BSD TV. This is a video of Ori Bernstein&#39;s October 2019 Nice Bug Meeting entitled Plan 9, Not Dead, Just Resting. Ori is someone I&#39;ve been running into at BSD CANS over the last few years. This current Westcoaster was nice enough to stop by the New York BSD Users Group, and for the true New York experience, we got a visit from the New York City Fire Department during his talk. Thankfully, it was a false alarm and Ori&#39;s talk was a success.
attended with lots of new faces and engaging questions. Enjoy. I&#39;m going to be talking about Plan 9, as you can see. So what, a summary of what&#39;s happened to it, or what&#39;s happening with it, why you don&#39;t want to use it, why I use it anyways, and generally the state of the union. And of course, what people can learn from it, even if they&#39;re not using Plan 9. So, it&#39;s already been covered, but feel free to interrupt me if any
If there are any questions, I&#39;d rather go off track or go and beat around the bush a little bit rather than just lose people or bore people. So just feel free to stop me and ask questions. So who am I? What do I do with Y Plan 9? So yes, I do have a Plan 9 laptop. It&#39;s that one over there. This one&#39;s actually running OpenBSD because I don&#39;t trust Plan 9&#39;s dual monitor output working on it. This one, but I am running this presentation remotely.
over plan nine so you&#39;re getting the real deal um I use it regularly I actually write code on it I log into other systems and develop code from plan nine sometimes and yes that probably means there is something wrong with me I am definitely way too stuck um okay so why don&#39;t you want to use plan nine well it doesn&#39;t have the programs you want this uh came from the uh nine fans mailing list uh years and years ago and it
details a typical new user&#39;s experience with Plan 9. Hi, I&#39;m Nita Plan 9. I&#39;m really excited to work with this new Linux. I hit some questions. How do I run X11? Where is Emacs? The code is weird. It doesn&#39;t look like GNU C at all. Do the Plan 9 people who wrote Plan 9 know at all about C? I tried to run Mozilla, but it didn&#39;t work. How come? You can tell this is an old post because it refers to Mozilla.
Anyways, sorry, there is no X11 asterisk. Plan9 does its graphics through the dev draw device, keyboard FS, dev mouse, and real. I&#39;ll go into a bit more detail on that. So that star actually is because the slide went out of date this September. Someone actually got an old port of X11 working, and you can now basically
run x programs on a Unix machine and have them display on Plan 9. Although amusingly enough, we got Chrome working before we got X-File. Yeah. So, yes. So Plan 9 has a Sage file? Yes. Can you do a Sage X-forwarding or a Sage? I don&#39;t believe so. I don&#39;t think that the X-forwarding channel has been implemented.
So this is the Emacs methodology. And I&#39;m not joking. That is the actual man page. There is no Emacs. There is a man page for Emacs describing why they, that they don&#39;t, making it very clear that they do not like Emacs. And it was intentionally left out. There is VI. That&#39;s not the right VI. VI is a mix emulator. Someone has ported Vim.
But I&#39;ve never actually tried using that. The web browsers are, to be blunt, crap. You have two web browsers shipped with the system. One is called Mozilla, one is called Apache. I will show them to you. They don&#39;t do Chrome, they don&#39;t do CSS, they don&#39;t do JavaScript. Does this use HTTPS? Yes, they do. Everything does HTTPS because the browsers don&#39;t actually do HTTP. You have WebFS that does HTTPS.
HTTP for them. This is Mothra. Oh, I have not started WebFS on this thing. This is how Google works on PlanB. Well, it&#39;s pretty good. And it&#39;s actually kind of usable.
TLS yeah that&#39;s the play all the in order to use the internet these days you need to use one of those garbage browsers like Firefox because the other things don&#39;t support TLS well they get a technology but this does yeah what is nice bug yeah sure oh yeah sorry to be totally off the bat about me but all right nice bug.org yeah
That&#39;s actually not bad. Yeah. It&#39;s pretty good. Yeah. I can actually use that. It&#39;s a really simple HTML. It won&#39;t render anything. No, it will not. So it&#39;s actually a standards compliant browser. Relatively. Yeah. Yeah. DuckDuckGo. Okay.
Oh wow. Yeah, I&#39;ve got a version that if you turn it on it&#39;ll it&#39;ll display this. Well, even no JavaScript version, right? Yeah, it goes to that process. Anyways, that&#39;s why I cut it off. So that&#39;s the web browser situation. You probably don&#39;t, that probably kills a lot of the usage. But, so that&#39;s what Plan 9 isn&#39;t.
system that you can probably that you uh that runs your modern programs that you expect on Unix. Uh it&#39;s not POSIX it doesn&#39;t uh anything you want will probably be there&#39;s a POSIX emulation layer but it&#39;s not very good porting is a chore a lot of the time it&#39;s easier to run your own or to write your own. So it&#39;s not uh a Unixy system but it is a Unix-inspired minimalist distributed graphical text-oriented research operating system. That kind of
covers most of it but it&#39;s a bit of a mouthful so let&#39;s break it down uh well the short summary slightly more facetiously is imagine all the good things you they told you were true about actually the good things they told you about unix were true well so first off it came from bell so it&#39;s got the same sort of design aesthetic as unix very minimalist very text oriented everything&#39;s designed around hierarchies of files
But it&#39;s also uh yeah it&#39;s minimalist so much more minimalist than Unix. You&#39;ve got 50 system calls you&#39;ve got a very a much smaller number of programs uh the and things are kind of put together by assembling namespaces. Um it&#39;s Unix inspired so you know it&#39;s kind for many people it ends up kind of in the uncanny value of Unix. You know it&#39;s kind of like
familiar but not really you know imagine your mom going for plastic surgery and coming back she looks kind of similar but you know there&#39;s a difference so distributed most of the time people use the word distributed to imply fault tolerance resilience and so on so I kind of hesitated using this word here but it is a distributed system the parts of it are not all on the same machine so draw term is that
actually is what I&#39;m using to remote into that box. And the way it works is actually by, sorry I&#39;m a little bit sick, by pulling in parts of that system&#39;s namespace into this machine. It runs it, it&#39;s it, it&#39;s actually basically a stripped down emulated Plan 9 kernel running in user space that does the remote login. So it&#39;s kind of a crazy way to do it, but it works.
And of course you&#39;re pulling you build the system by pulling in resources from other systems. I&#39;ll go into more detail on that later. Graphics. So you can&#39;t actually use Plan 9 effectively without it without graphics. The way that Plan 9 is designed you really want to have some sort of graphical terminal so that you can actually do things. The command line without
graphics is extremely extremely variable it doesn&#39;t give you command line history it doesn&#39;t give you line editing so you can&#39;t actually mouse arrow back and forth edit the text you&#39;ve already typed it doesn&#39;t give you really anything because that&#39;s all be pushed into the Windows system so any any text is managed by the Windows system so for example you can see LS I have got that listed I can
click back here and edit the scroll back and that&#39;s how you do the line editing if you want to let&#39;s pull up acid I don&#39;t care I&#39;m just getting some stuff into the history from outside the program and then quote quote quote pulls up history not easy yeah
And you can see I&#39;m actually looking through dev text and I can find the previous lines. The code script is used for rerunning command line programs. I forgot that it actually looks for the prompt in the front for it so it filters out the... So the demo didn&#39;t quite do what I wanted, but you can actually look through all the command line history, poke at it, and that&#39;s done through the Windows system, not through the shell itself. Okay.
So graphical, text-oriented. As you can see, there&#39;s not, everything&#39;s graphics, but all the graphics that it&#39;s showing right now are text. Everything&#39;s designed around manipulating text, splitting lines through text, and so on. And it&#39;s kind of designed around, well, the entire point of all the graphics is to make it easier to deal with text. It&#39;s also a research operating system.
So the design of it is, part of the reason it&#39;s so simple is because it&#39;s a lot easier to mess with the system if you don&#39;t have tons and tons of his-ossified history. Uh, the- it comes with a bunch of research papers. Um, I- here I can actually make this lot bigger more easily. Uh, oops. Uh, we just type a new button. Type a new button. Oh yeah, yeah sure. You can type
If I want to type a new window Yeah, so the Yeah, this is annoying I accidentally deleted my font size setting But you okay, so it comes with a bunch of research papers And so just to summarize the differences for graphics instead of Excel
you&#39;ve got RIO which is the Windows system. Instead of the ship instead of born shell you&#39;ve got RC. RC is has a lot of useful features on top of born like having lists so you don&#39;t have to worry about word splitting killing your killing any script that has spaces. This is probably the most useful change in RC but overall it&#39;s a much more regular and less quirky syntax.
The editors you get Sam and Acme instead of Emacs and Vim. For password management you get Factotum which is kind of the equivalent of SSH agent and SecStore on an off-server which actually securely stores your password. X11 is replaced with KeyboardFS, Draw, Mouse. NFS you get ExportFS over 9P. So that&#39;s the details of that. And a whole bunch of innovations that came out of research on Planet Earth.
include UTF-8 which was apparently done in a diner in New Jersey. Are? Seriously? Yes. Yeah, seriously. Wow. Jersey represents. Yeah. Basically they kind of, the story is, there&#39;s a much better summary of it than I can give right now online, but in a minute or so they basically looked at what some standards body, I think IBM, was proposing, went, this isn&#39;t very good, let&#39;s
do it better before they actually ratify the standard. So they did, and now we have UTF-8. The proc file system on Linux, that came from Plan 9 indirectly. Ported of compositing, which is the whole drawing with transparency and so on. Plan 9 did that first. The X11 X render extension explicitly mentions Plan 9 as the inspiration. Namespaces, like you&#39;d use in Docker, those came from
Plan 9 communicating sequential processes so for example the communication model of Erlang and Go a lot of the initial implementation came from the Plan 9 research environment it&#39;s not the only place that that happened Tony Cor did not work on that on Plan 9 but it&#39;s one of the places where they really started experimenting with it and it looks like you&#39;re taking a picture so I will pause okay so cool and that&#39;s what
Happened at Bell Labs. Bell Labs died. So What&#39;s happened since? Well There are a bunch of forks There is nine legacy or plan nine contract which is really a collection of patches nine Adam Harzi nine front Apero is next plan B inferno Probably more forks from users at this
point maybe actually I don&#39;t think that&#39;s true I think there are more users than forks but I wouldn&#39;t bet on it anyways so quick summary of what these forks are there&#39;s nine legacy which is essentially a patch collection for the labs version of plan so they&#39;re not taking and really modifying it too much but they are collecting fixes new toys new hardware support and so on they&#39;re
keeping the most important patches in the Git repo, the rest are just kind of apply as you like. Nine Atom is, again, Sigma, it&#39;s taking the Bell Labs stuff. They&#39;re not really touching the artwork. But they are just adding some hardware support to it. I&#39;m not sure what the current status of that is. The site seems to be down, but it&#39;s what these things come up and go down as stuff happens. And I believe Nine Atom is just one person. So there&#39;s Harvey.
which is more modern modern uh more Unixy they&#39;re trying to actually make the uh POSIX environment good enough to run Unix programs without spending weeks porting them uh they&#39;re trying to port to move the compiler suite to GCC and clang they&#39;re trying to uh hook it up to I don&#39;t remember um I think they&#39;re trying to add the sanitizers all of the nice toys there&#39;s uh ACROS
which is a research work that the University of Berkeley maintains and they&#39;re basically trying to do multi-core multi-core multi-core exploring a bunch of new ideas trying to figure out how to make multi-process a more native concept they&#39;re doing some neat stuff and pulling in a whole bunch of Linux eBICS as well I think they&#39;ve started using RCU for performance sake within the Plan 9 kernel instead of locking RCU is essentially
read copy update which is block free multi-reader single writer concurrency I can go into more detail about that later if people have questions but I&#39;m not going to go too deep into that there&#39;s Inferno which is another it&#39;s not really a fork it&#39;s another interesting OS designed around Plan 9 but it&#39;s runnable on top of other operating systems too so if you want it
Flang 9-ish system that can that you can run on top of Windows, Mac OS, Linux, Plat 9, and so on, as well as on bare metal, even down to machines with one megaram and no MMU. They do that. They&#39;ve written that in which is a JIT compiled language kind of like which runs on something vaguely like the JVM. It&#39;s a neat system. I haven&#39;t done too much with it, but yeah, so that exists.
And then there&#39;s 9Front, which is the one that I use. It&#39;s actively maintained. It has great hardware support as far as these things go. So by great hardware support, I mean I can pick, say, ThinkPads and not spend years and years of digging to find some sort of support in hardware. Like I&#39;m using an X260. I&#39;ve got Wi-Fi. I&#39;ve got native resolution and so on. I think writing drivers
using binary blobs native drivers so so they barely have enough users but they have developers who are writing yes reverse engineering or taking open source drivers uh the the hardware support is still not it&#39;s not giant but as far as so i&#39;m sorry what are the chips that&#39;s not the drill into this but i&#39;m just curious which groups support you know uh which chip oh wi-fi yeah wi-fi
It&#39;s basically DINTL chips. DINTL? Yeah. I think it&#39;s IW. There are some ancient ones that are supported. I&#39;ve got a slide on that too. Oh, I should show you. So most of the Ninefront developers, or the main ones, are German. So of course I have to show you the German engineer. Oh yeah, I made a little click on that. And that, I said text-oriented. It knows there&#39;s, it&#39;s a J, it&#39;s Png.
knows where the PNG is and it goes okay I should open that in the PNG viewer I thought it was a hard copy picture for the projection no no no so basically the plumber is a neat piece of another neat piece of engineering basically what you do is you send it messages it looks at the message and goes so what can I do with this text is it a C file in my current directory or a C file that I know about let me open it
the editor. Is it a URL? Let me open it in the browser. Is it a message from the email program? Okay, I should show a notification that you&#39;ve received mail. And so on and so forth. So it&#39;s all text-based. You can, and you just, in this case, middle-click on it and it just says, okay, do your thing. Can you do it without a mouse? No, not really. There&#39;s a...
file association it&#39;s it&#39;s actually looking at the file header it can yeah it&#39;s not just like oh this is a phg opens picture it&#39;s more than that right uh you can do that i believe it&#39;s you can basically attach any arbitrary script uh but you can do it in the os yes but it&#39;s at the level of the like the windowing system that recognizes it like it chums it into uh the file name it&#39;s not
It&#39;s not within the editor. It&#39;s not and it&#39;s not like strictly like half specific is it? Like as long as it goes it goes through the policy and finds like policy says German engineering at the end of the chain so it says okay I found it open it. It&#39;s just like using magic words and operating systems. Like you literally modify it right there on the spot and just add new things to it. That&#39;s cool.
Okay, here we go. So here are the rules for the plumber. Oh, and I just broke my font. Oops. Anyways, you can see the kind of how they do it. Type this text, destination is MS Word, plumb to MS Word, start, word to doc, font. Email addresses get a new window, plumb start, et cetera, et cetera. So it can match email addresses and say do that.
Okay, so let me restart my font file server. Let me delete this file and then restart my font server. And now fonts are back. Okay, so, oh yeah, so German engineering PNG. Anyone know what the photo is? I&#39;m guessing. Is that the LHC? No. That is the...
They have a sense of humor Anyway Yeah, so hardware support it&#39;s actually got pretty good hardware support
It&#39;s better or worse than the most? For the most? I&#39;ve heard rumors that it&#39;s better. Better? I don&#39;t know for sure, but it actually has hardware support. I can run it on my hardware. Most of the time, as long as I don&#39;t care about Wi-Fi, I can toss it on most hardware and it&#39;ll just work, at least with Visa drivers. So going into specifics, there are Wi-Fi drivers working on
cards mostly Intel ones and I&#39;m using them right now to talk to that machine in Intel graphic native graphics drivers up to Haslo they were written in I believe a week part of it is that we don&#39;t care about 3d graphics so yeah yeah if you don&#39;t care about 3d all you really need to do is tell the graphics card hey I want this
this area of memory to go onto the screen and then you draw onto that. So I&#39;m guessing this means that playtime does not in fact run Doom? Ah, I don&#39;t have any data for it. But it does have Doom. It shows it has Doom, it ships with it. You can&#39;t run Doom on the PC with the play? Is there a quick portion?
Oh, that&#39;s not surprising. VMX, virtual machines. You can run OpenBSD on Plan 9 if you want. It&#39;s slow, but it exists. I see someone going, why? Well, if you happen to want a modern web browser that can do JavaScript, then you want to have an OS that can run a modern web browser that can do JavaScript. So for that you need virtualization. There are other reasons.
too you want to be able to test your kernel without actually rebooting the machine and debugging it and so on but yeah having it uh having a virtual machine is super useful and it even runs ancient versions of windows i think um and the forwarding for uh for wi-fi bridging um that&#39;s done with mat daemon the mat daemon it for it bridges your ethernet for you don&#39;t ask me why it&#39;s called
that but uh NVME is supported uh that was done in one weekend the uh SINAP uh his actual name is Friedman Gerald but uh I think everyone calls him SINAP because that&#39;s his nickname he is insane he is a machine for turning data spec sheets into code when I uh tested out his NVME drive
and started using it, it didn&#39;t work. We started debugging it. I figured out why. The drive didn&#39;t conform to spec. Right, but wireless is probably worse. Wireless is... Specs versus write and go, right? Well, yes. Wireless is, well, complicated and also there&#39;s a ton of chipsets.
TTM. So I&#39;m using that right now for this display. It works, hinting and all. It&#39;s independently developed. It&#39;s about 5,000 lines of code. It does a whole bunch of... Oh, sorry. Let me... Do I... Why is it not plumbing? Oh, it probably is plumbing to the other window. Yeah. But it&#39;s loading it. So, yeah, you can shape it. You can do...
Why is that not plumbing? Let me just try one more time. Yes no maybe
No, okay, let me figure out why that I might not have had have that file in that okay, maybe I forgot to copy that file I&#39;ll dig that into that later, but it does Asian text so Nicely laid out CWFS is the default file system it does snapshotting and lets you look through the history of your files so for example I can do local manifest dump
that loads up that mounts the dump and then I can look at my files from 2018 or 2019 I don&#39;t know and yeah well they&#39;ve got support for it and here&#39;s my code way back then I didn&#39;t have that much code sitting on that
But yeah, you can dig through the history of your files. By default, it takes a snapshot every night. And it&#39;s had this since probably about the 80s. Or early 90s, I guess. Git 9, that&#39;s my baby. So I&#39;ve implemented a complete, I&#39;ve done a complete Git implementation for Plan 9 from scratch. Lets you do all of the usual source code management stuff that you need. It&#39;s kind of fun.
system based, does the init push pull export import. It&#39;s got a clean, easy to use, well, easier to use command line interface than upstream Git. I&#39;m not doing the clone. The upstream Git&#39;s UI is terrible, so let me do something good. To give you an idea of how the kind of things that you can do internally, here is the full implementation of Git merge. That&#39;s all.
It&#39;s just a shell script. All it&#39;s doing is looking at which files which branch you want to well it starts by mounting your git file system decides which branches you want to merge then walks through the file system&#39;s view of the git file system&#39;s view of the data on that branch what you the git file system&#39;s view of the other branch and just use the uses the git3 command line
to merge you don&#39;t need that much once you can actually access the data from your command line okay so cool but big yawn you&#39;ve already got all of these features why the hell do you care because you&#39;ve got units it does this what&#39;s the point of all this shit well the thing is that
All the features that Unix has are nice, but the power of Plan 9 actually comes from something else that you can&#39;t get by adding features. The power of Plan 9 is, the essence of Plan 9 is 9P and namespaces. And that&#39;s essentially how you put the system together. So 9P is the Plan 9 file system protocol, and namespaces are essentially views into the files. Every window has its own namespace.
So here is the full list of operations you can do in IP. There isn&#39;t anything else. All your communication with the system goes through this. The only things you use for, the only things you can, so all the system calls map to this or process management or namespace management. So you have your data access and manipulation, you have fork
and you have mount and bind and basically that&#39;s and nsec which gives you the current time. Those are your system calls. Everything else is done through this. There is no other way to talk to the system. Now this is a network protocol and because the only way you talk to the system is through the network protocol everything becomes network transparent for free.
are the way that you manage the view for all your programs. This is essentially the way that this is a view well a short snippet of the namespace for the current process or for a no longer current process. So you take the and this is from a remote log so mount term is your remote system. Mount term&#39;s devices are mounted over your local devices.
in this case, which means that opening DevDraw on this machine or on that machine opens it on this machine. So a program that says I want to draw something to the screen over there gets redirected here for free. There&#39;s no code in that program that needs to know. Slash proc is slash proc. Hash devices like this are magical bootstrap things, so you can
So you basically get a magical hash P device which you can bind into your namespace and start using it. Same with the pipes. RIO is your window system. And you kind of assemble any processes view of the system around it from these namespaces. But even then, this is cool, but it&#39;s not about 9P. Who cares that you&#39;re using
specific protocol. It&#39;s about using unified mechanisms that you can interpose. And that&#39;s really the lesson that you can take from Plan 9 and port to other systems. Pick one way to do something and then once you&#39;ve picked that way of doing it, you can make sure that you can replace a component and put a layer in front of it and now you&#39;ve got a massive amount of flexibility. This is also why you can&#39;t take features from Plan 9 and move it to Unix.
Because adding one more way to do things to Unix will not give you the ability to put a layer in between and intercept or rewrite or view all the operations that a program can do. So on Unix, I can&#39;t put in a interposer for dev draw or dev mouse or dev keyboard and rewrite or change the thing, change dev keyboard to
say add in input methods for Japanese input easily, that has to be specially hooked into all the programs because there is no unified way of doing it. And all the features you want, unless you manage to guarantee that no one&#39;s using them anymore, well, then you just can&#39;t. So...
Well, it&#39;s all, yeah, data level, yeah, but there&#39;s other things that people have. I mean, every, all the BSDs have a bunch of plain old ports now.
Right? I mean, there&#39;s other user land layer tools that are out there that are important, including the C compiler. Sure. I mean, you can, yeah, you can definitely get an Ubuntu with the Plan 9 C. Yeah, well.
Okay. So, the essence is really... I&#39;m not going to take the bait on that. Okay. You can, fine. You can get a free PSD with the Plan 9 C. Well, I mean, no, but I mean, I brought this up earlier, but like...
And I know when everybody was all hot on PCC as replacement for GCC years ago, 15 years ago or whatever, there was a lot of talk about how Plan 9 C compiler was doing a lot of wonderful things that people would love to have. Yeah, and sure, that&#39;s true. There&#39;s a lot of good stuff in Plan 9 user space. But those are just features that you can port. I don&#39;t think that they&#39;re really the core idea of Plan 9. No, it&#39;s a fundamentally different operating system. I agree.
Yeah, of course. Yeah. But anyway, that&#39;s my point. So, you know, GRP, so things that are happening in outside the client side world, gRPC, it sucks, but it&#39;s great. And Google is using it everywhere and gives you the same kind of, at least if you&#39;re at Google, it gives you the same kind of one interface to all your systems. Some places do the same thing with RINST and that kind of thing is, you know, really helpful. Docker, it&#39;s got the same kind of thing.
It&#39;s a really nice way of managing your namespaces, putting things into little boxes. But it also sucks. So, 9P, I still think it&#39;s better than these guys because it&#39;s universal. So, Docker, gRPC, all the other tools on other systems are universal by convention. In other words, people kind of shut their eyes and go, no, no, no, no, nothing else exists. But on Planet...
And 9P is actually the only way you can talk to the system. And the other nice thing is that it&#39;s actually implementable by you. So when I was working on, at my last job, we ended up using 9P for some firmware interfaces. And yeah, we didn&#39;t get the universality, but it&#39;s a nice way of actually connecting to firmware and modifying it. And it&#39;s, was something like 500 lines of code to implement. So, just to clarify, you&#39;re talking about 9P not on
I&#39;m talking about 9P on well 9P universe being universal is on plan 9. 9P being implementable by humans that&#39;s all over the place. For work I was not using it on plan 9. That was sitting directly on a STM32 and experimental implementation 192 kilobytes of RAM etc etc and then we were talking to Linnae too.
We were talking to that firmware through Linux using a user space implementational thing. Um, can any of the colleagues know what you&#39;re doing? Yes. Wow. So, uh, I think that&#39;s the one thing that made me go, this story guy has really weird ideas, but they always seem to work out. And then they just started letting me do what I wanted to do. Um, at one point, we were trying to figure out how to do RPC.
within Linux ignoring the not to the firmware and I wasn&#39;t even even in the room when the CTO suggested we use 9p and what is GRCC sorry what is GRPC oh okay gRPC is Google&#39;s uh RPC protocol so uh uh yeah gRPC it&#39;s basically uh protobufs yeah okay it&#39;s a way of describing this service
these messages and has these functions you can call them. Uh yeah. Oh yes, yeah it&#39;s actually kind of weird how 9P seems to become the traditional default implementation for connecting the native OSS file system with a virtualized machine&#39;s file system. Now to be fair,
It&#39;s a very heavily extended 9P. So 9P is basically Ken&#39;s idea of, Ken Thompson&#39;s idea of, this is what a VFS should look like. And then, so it&#39;s got these many operations. 9P for virtual machines has got these many operations. And it&#39;s all the stat stuff, all of the mmap, et cetera, et cetera. But it&#39;s still there. So for example, you&#39;ve got
slash net instead of sockets. So on Unix you have a whole bunch of special system calls for creating sockets. On Plan 9 you have netTCP clone which creates a new connection and then that gives you a night reading the clone file descriptor lets you control the connection also tells you okay so your data is sitting over here in the netTCP zero data.
And that that you open that file and start doing I on that to do your TCP which is nice. As opposed to syscalls. As opposed to syscalls. Okay so isn&#39;t there a real problem with giving fine-grained control over syscalls then? There aren&#39;t that many syscalls. But.
Right but so I need to give an application you know I need to talk TCP for anything all of a sudden. I&#39;m giving one syscall. It&#39;s a file so it&#39;s a permission base. Right, but I&#39;m giving away like everything. I&#39;m giving it a lot more less fine-grained control than I would with syscalls, right? Well, with... The assumption is that if you have limited syscalls, one syscall does a lot more than a unit system. One syscall lets you do more things, but you have the control to, you know, to basically allow open...
TCP socket. If you don&#39;t want TCP sockets, don&#39;t put it into the process&#39;s namespace. Now at the same time, there&#39;s no firewall, so you can&#39;t say I&#39;m only allowing TCP on port 443, but that&#39;s an implementation issue, not a, or quality of implementation issue, not a fundamental limitation. What you could do, if you really wanted to, was write, well, I&#39;ll talk a little bit more about that in a second. It might even be the next slide. Okay, now, so this is actually,
shell script that opens TCP connections and starts talking on IRC. What you&#39;re doing here is a whole bunch of file descriptor manipulation saying, you know, dial, well, start by figuring out who you&#39;re talking to. So the address is the second connection. Slash net is the network stack you happen to want to use. Do IRC and nickname. Do IRC will be your script that actually does IRC. And so you start by
dialing it using NDBCS query which basically looks it up and then you basically run your command. There&#39;s nothing too special the only trickery here is that you need to actually keep the script running so that the files descriptors don&#39;t go away when the command disappears. You can do something vaguely like this on Linux except you can
can&#39;t open net data you&#39;d need to write a special program that does TCP. This is manipulated entirely through the shell script. Now there is more. You can actually interpose your own network stuff. So SSH net is a program that takes your well that it&#39;s a file server. What it does is it takes the network stack that sorry it emulates a network stack but instead of doing
working locally it tunnels it through TCP so this is a TCP sorry an SSH proxy that programs don&#39;t know about basically SOCKS tunn tap I guess is the closest script you&#39;d have on Unix and you can do SSH through that this is just namespaces and IP and if you wanted to restrict ports well I would do it through something like this where you&#39;d have a program that basically
puts itself between the network stack and your program and says, no, no, no, no, no. You&#39;re trying to talk on port 444. You&#39;re only allowed 443. Goodbye. So there&#39;s more. If you want to use a, instead of network address translation, you can just mount someone else&#39;s network stack and put it on top of yours. So now you can just tunnel your network through it. Again,
namespace is in 9p. You don&#39;t need any special support in the program if you don&#39;t need any special support in your operating system. All it is is mount basically. So Rio is doing the exact same thing except with dev draw. So dev draw is actually the entire screen and what Rio does is it says okay let me split that up into rectangles. Each program thinks it&#39;s got its full dev draw full
screen. Rio just kind of creates a virtual one and splits it splits things out. It does the same with mouse and keyboard and multiplexes it between the windows that it&#39;s emulating so you can actually run Rio within Rio and it doesn&#39;t matter. Programs don&#39;t I well yeah it&#39;s a slight lie I say programs don&#39;t care there&#39;s extra information that Rio gives them like the window name and so on which you can set but for the most part it&#39;s the same dev draw same drawing protocol as anything else.
And help, even this slide. So my script here, this is my slideshow program. I have a text editor that actually looks at the slide list and manipulates the text editor&#39;s contents of the window. So here is the entire slideshow program I&#39;m using here to present to you. So...
So that gives you the whole 9P overview. Now what do you do with, so how do you actually put things together? Well, typically a Plan 9 machine, a Plan 9 network has several machines. You&#39;ve got a terminal, you&#39;ve got a CPU server, you&#39;ve got a file server, and you&#39;ve got an auth server. So, oops, wrong slide, wrong direction. So the terminal is just a dumb terminal, local device access. Draw term, which is what I&#39;m using to remote into that system.
resources, hey I want that machine&#39;s keyboard, hey I want that machine&#39;s uh user list, hey I want that machine&#39;s uh file system and that machine&#39;s files. And then Factotum is basically your uh user uh like SSH agent. It&#39;s nothing too special. Um and that&#39;s basically your secret management and stuff. So basically you compose things into a network by gluing things together with namespaces. Uh seamless uh
to remote resources it falls out of the whole model it come the way the way that you administer and use the system it basically comes for free with the unified model now of course this has a cost because everything is so general you can&#39;t really do special hacks like send file which assumes local file descriptors and so on the generality is
The generality isn&#39;t free, but the composition is. Okay, so I&#39;m going to skip going through our CPU because I feel like we&#39;ve been taking long enough. Actually, I&#39;ll just show you roughly how long it is. This is the script that you actually use to remotely log into a machine. The core of it is really just mount. I&#39;ve been talking about namespaces and binds, basically all it does
go to this machine, take this thing&#39;s devices, put them on top, and you&#39;re done. Cool. So that&#39;s that. Anyways, that&#39;s it. I hope you have enjoyed your bit of OS necrophilia. Yes.
I believe that at some point in the past Pearl was supported with Plan 9 but we haven&#39;t had a smoke test with it in many years. So I&#39;m wondering if you have any information on the usability of either Pearl or other dynamic programming languages? There is Python that ships with the system. Really old Python? Yes. 2.5 something? Yes. There is a 2.7 that&#39;s been ported, but really Python&#39;s only around because
people want mercurial, which I am working to kill. So the idea there is that we&#39;re hopefully going to just move that to ports and get rid of the base system Python. There is a Perl port from 2003, I think. And that is, I don&#39;t think it&#39;s been touched since. I would be interested in seeing someone update it, but yeah, most of it&#39;s just RC and
There&#39;s Python shipped, but no one really seems to like it. Go is actually, it&#39;s not really a dynamic language, but it is supported and is ported. There is, oh, hmm? By the author? Yes, yes, I believe the author of, or I don&#39;t know if it is the author of Go, but there is definitely Go port that&#39;s actually
can&#39;t be updated. And then there&#39;s an open file that&#39;s happened recently. Wow. Okay. For some reason, every time I look at the way you can edit the real environment, for some reason it reminds me of a small talk environment. It&#39;s dynamic, ever-changing. You can update it right there on the fly and the changes will apply more or less immediately. I mean, when they were developing Plan 9 and real, they look at small talk and say, hey, this is a pretty awesome idea. Let&#39;s do this. So this is actually not real.
This is Acme which is the text editor. Rio is the window system around the editor. But if you want to, so the inspiration for the editor was not Smalltalk but it was overall which is Nicholas Wirt&#39;s or Wirt&#39;s system. Basically he he started doing the dynamic text stuff and Rob Pike kind of looked at it and went I like that I&#39;m stealing it. It does it does remind me a lot of Smalltalk.
basically change an aspect of the environment. It takes place immediately and you just get marks using it. Yeah, so Oberon is really the place that that came from here. So, um, sorry to add on really quickly. Go ahead. Are there other languages available on PineLine besides the ones you mentioned, Perl and Python and Go and O-C? C? That&#39;s that it? My language is ported. There are a couple. Do I have ports on this system? I mean, I think I do.
Uh, Meridan. Sorry, what was it again? Uh, Meridan, I&#39;ll type it actually. I&#39;ll just type it up here. Yeah, so that&#39;s my language. Meridan, yep. Oops. And here is...
Okay, so not too much. There&#39;s a tickle port. And so... Oh, there is a squeak. Oh, there is a squeak. Huh? So it&#39;s still small talk? Yeah. So it&#39;s not a... There&#39;s a lab? You read those lab notes? Yeah, yeah. So there&#39;s a Fortran to C. For all those Fortran programmers, go.
Go 1.4 which is used for bootstrapping and a wrapper around it that pulls in Go 1.4 and then builds in Go Bootstrap. There&#39;s Lua, there&#39;s Merdin, there&#39;s OCaml, there&#39;s Scheme, there&#39;s Squeak which is smalltalk, there&#39;s Tickle and then there&#39;s TinyScheme. The Perl port is not in this list. It does exist. It seems to
Someone used it for porting Git actually fairly recently. So the upstream Git, not my re-implementation. Yeah. Did it run by Grayland with close week? Yes, I don&#39;t think it&#39;s... Oh yeah, new stuff. I think an early slideshow of Mix as a fork of Plan 9. Is that... That is a different Mix. Oh, is it? There is a fork of Plan 9 that is experimental.
with scheduling so what Nix does is basically trying to it&#39;s plan 9 but with the idea of having a kernel core and application cores and yeah you&#39;re saying that&#39;s not the Nix that&#39;s not the probably not okay they are doing they were doing some interesting stuff where basically the idea is that you can have cores that the application only runs on top of and the system calls go to the kernel to CPU
which is not going to affect scheduling. And the idea behind it was as CPUs start to have 64, 128 cores, you&#39;re going to have enough that all the busy applications can just consume enough core to themselves and don&#39;t need to be scheduled. So if something needs to happen, it&#39;s going to be super low latency. And that was coming out of the high performance computing world. So IBM, I think during that era, was doing a bunch of research on supercomputers with one line.
Yes. First, I&#39;m very, I was, for a long time I was not into Windows 99 because it seemed like I needed to use a mouse. But now I see that it&#39;s very powerful to be able to click on things. So it&#39;s made me want to, it&#39;s made me bring it to, oh you want to click on the mouse? Yeah. No. So I&#39;m playing 99 because the mouse would be useful. But with Linux 99, maybe the mouse would be useful suddenly. Now I&#39;m wondering, um,
Of course the issue is that not like all the software I use isn&#39;t going to work. It would very well, oh yeah. So I&#39;m wondering if there&#39;s an easier way to deal with this problem. Currently I have like one main computer and then anything that I can&#39;t, that I&#39;ve given up on porting to that computer, I run somewhere else in SSH. Yeah, but for example for a time I had it that, now I have the scanner working, but for a time I had it that I SSH&#39;d to another computer. I had a program like let&#39;s say I call it scanner, and that would log into another computer.
So if I&#39;m doing that is there a better way to plan on doing that than doing the exact same thing? I mean you can SSH and do things directly like I just SSHed into my OpenBSD box. You can do SSHFS which mounts SSH. It&#39;s I mean
you&#39;re still talking to a Unix system. So there&#39;s only so much you can do. So it&#39;s fuse support or? No, I mean it&#39;s SSH, it&#39;s 9P. It&#39;s not SSH, it&#39;s a different SSH client. Yeah, it&#39;s a different SSH client. It&#39;s Plan 9, everything&#39;s a server. Yeah. As opposed to everything&#39;s a client. Yeah, and basically, I mean, Plan 9, if you thought OpenBSD reinvented the realm was bad, Plan 9 kind of takes it to the next level. You know, we&#39;ve got our own SSH with our own SSH implementation.
uh that was another synapse project i think it took a week or two and it&#39;s 1500 lines of code would would you or have you run a public box on the internet with plan nine uh i have not i might but there are public boxes i believe sdf uh there&#39;s also nine grid where basically
there&#39;s a shared file server and someone&#39;s giving out free accounts to whoever asks I believe and Which which is the fork you using I&#39;m using nine front nine front yeah the front fell off What about I mean what I&#39;m actually most curious about is is I mean I know the origins and the devs were of the developers about the beginning are any of them still involved or is this just like Let me see if I can find the
QA really quickly? Frequently question and answers. I didn&#39;t know this, I&#39;m going to get shot at it, I don&#39;t know if that was, I didn&#39;t know they did it. Yeah, so by the way, that gives you an attitude of the drill. Everyone knows about that format. Okay.
Plan so section one plan nine is not for you just to emphasize it in case the start of my presentation was not enough This is not the fastest network I&#39;m tethered to my phone so Actually, why did plan nine&#39;s creators give up on plan nine?
I can&#39;t read either. Yeah, I&#39;m trying. I&#39;m waiting for the pictures to load. There are pictures. The text itself is way too small. I see a contrast in colors. Yeah. So for the people that can&#39;t read, I was your pilot. Basically, the people that were working on Plan 9, Bell Labs died. They stopped getting a salary and they went on to work on other things.
Mostly at Google. When they went to die at Google, yeah. Yeah. The preferred phrase, I believe, is went on display. Yeah. So basically, yeah. So Google is where bad folks go when they die. It&#39;s their way to fire and fry. The best recording tool Google has. To be fair, it&#39;s like Ken Thompson and Rob Pike working on Plan I, then when Google made the single video, yeah. And that&#39;s it. Yeah.
Well, Ken is now fully, I believe fully retired. Yeah. Yeah, Ken is retired. I did see Ken though earlier this year at um, the Vintage Computer Fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the computer fest. He&#39;s been to the
in plan nine I believe at the end of August. There&#39;s an inferno somewhere on the plan? I don&#39;t know. There&#39;s a port but it&#39;s not really updated. Yeah. So a port for what? It&#39;s an inferno the operating system yet. Yeah. Or the Pi. Yeah. So the Raspberry Pi was a interesting to watch happen mainly because the Raspberry Pi 4 is ridiculously complex.
And the bug that really caught people for a long time, by the way feel free to just go talk amongst yourselves because at this point I&#39;m just telling stories. But basically what happened, the bug that really hung things up for a few weeks was the Raspberry Pi would work and then randomly some ethernet traffic would happen and all interrupts.
everything would freeze for exactly 42 seconds and then it would resume which raspberry pi pi 4 it&#39;s not sharing the bus anymore with usb and everything else no it&#39;s got real internet so yeah so sitting there debugging trying to figure out everything that&#39;s going on uh getting well trying
to get people at Broadcom to give some hints and so on and so forth and eventually they kind of after enough banging they figure out exactly what&#39;s happening if you walk off the end of executable executable memory you end up getting well the bus kind of goes wonky long enough for a hundred megahertz timer to tick over 32 bits which is 42 seconds now
None of the memory accesses that they were doing were wrong. So they were looking over that with a fine-tooth comb. But it turned out that the memory had been mapped in the page tables with an executable bit. So what was happening was the CPU was going, okay, you&#39;re running along these instructions. Let me prefetch the next ones. And that fell off the end of the executable of valid memory. The bus kind of went, ah, my head&#39;s
on fire and this the whole thing locked up for 42 seconds eventually timer wrapped around and everything started working again and it turned out that they had actually thought of this initial or the the reporting people had initially thought of this so synapse but there was a typo misread of the doc documentation I&#39;m not sure so he was saying it wrong
bit on the page table so yeah so uh has has anyone or do you think will anyone be masochistic enough to try and port this to the RISC-V architecture? um compilers have to happen first but why not a compiler I could see somebody import it to this fine recently yeah I think yeah I think there was uh yeah
Okay, so then it&#39;s possible. I think Richard Miller was doing some stuff around that. I&#39;m not sure. And Charles Forsyth is usually the compiler guy, so he might have that stuff too. It&#39;s probably buggy because nothing&#39;s really using it at the moment. But if it exists, the bugs can be fixed and someone can do a port. It&#39;s just a matter of someone wiggling fingers.
I&#39;m intrigued by the point about Go. Now I&#39;m thinking, everyone seems to like Plan 9 and everyone seems to hate Go. What should we make of this? Nobody uses Plan 9. Nobody uses Go. I&#39;m sure that a lot of people will hate Plan 9 if they had to actually use it. You had a question about that?
Did that actually work for different sized fonts in different windows? Uh yeah. Yeah, sorry. I probably should have been changing the fonts more, but uh it was a bit annoying to switch them around. So you- Yes, sir. We&#39;re talking a lot about the words and the fonts being clickable, but I think I- I guess I&#39;m worried that I can&#39;t tell what&#39;s clickable and what isn&#39;t. Like there&#39;s no- Everything&#39;s clickable. There&#39;s no like UI. What does that mean like? If you click on a word that does-
correspond to what if you click on the word like your up in there like when you go past that oh uh let me see your uh i don&#39;t see your so let me just type it yeah sure okay so you can right click and nothing and it&#39;ll just search for the next one middle click will just do nothing you might be able to put rm in there oh rm will delete it ah sure uh
It just seems like there&#39;s a lot of potential unintended consequences. It&#39;s like a terminal. It&#39;s not like a terminal. You could accidentally do something. I could accidentally do something. Yeah. All right. Okay, so we went over the languages that are available in Plan 9 or available for Plan 9. So let&#39;s get to the next slide.
which is porting software to Plan 9, how easy or how difficult or how pulling and seeing is it to bring any kind of software over to Plan 9, whether it&#39;s Unix, Windows, Mac, whatever to Plan 9? Windows isn&#39;t happening. Well, I don&#39;t think it&#39;s happening. But like I guess like anything like, you know, maybe POSIX compliant. I mean, does Plan 9 have POSIX compliance in it? It has an integration layer, yes. Okay, so if I bring anything POSIX compliant to Plan 9, how easy would it be to just compile?
than run in plan nine there&#39;s a chance it&#39;ll work um there it&#39;s it depends on how uh much or how much the surface area you use is so for example there&#39;s no m map i believe the closest that we do is if you try to m map something um a lot of places will do a read-only m map which you can just emulate by doing a read of the data and
with malloc and then free it instead of m on map. There is, well none of the software that&#39;s been ported so far has needed pthreads, so there is no pthread support, at least not in 9front. There are patches floating around that implement pthreads, so if someone actually tried porting stuff, I would be happy to import pthreads into 9front. So I guess like anything that doesn&#39;t really need any kind of YP system calls and the other
units or units like operating system should generally be okay to run I&#39;m not yeah yeah yeah all right so it&#39;s like if I wanted to do like a what I&#39;ll throw this one up in the air let&#39;s say like if I want to do like um Warwick tools for example oh I think we have those we have Warwick tools yeah uh again console again yeah yeah those are there all right what about like 5p code or 5p code got it all those two yeah so anything that&#39;s like I guess like yeah that does the
wacky system calls or any kind of wacky libraries will run okay yeah if I can call them plan nine yeah now the one that we would like which no one&#39;s actually done yet is FFmpeg that one I believe there&#39;s a bunch of assembly that might need to be forwarded but it I think someone&#39;s started looking at it I&#39;m not sure what the status is I don&#39;t think they finished looking at it so on that note since you mentioned FFmpeg let&#39;s try the
I wonder if that well first off you need the graphics yeah those are the hard part I think m player you probably want to write a new window back end yeah I mean let me call it from like from the command line because I know you can do that with with m player you can call it the command line say like m player run you know this file
Yeah, and it launches it in a simple window. Not sure. Might be doable. The other thing that we&#39;d like to do is, you know, when, well, I mentioned that you can run VMs. I mentioned that X11 has recently been ported. The goal that I&#39;m hoping we can eventually get to is something kind of like Windows substitute for Linux, where basically you have the Linux kernel sitting beside the Pine9 kernel in an emulated environment, and whatever hooks are needed to make it not so
using it yeah so i guess like you can almost be like it all sounds like what you&#39;re what you&#39;re saying is like calls like the the bsd jails yes kind of i guess kind of like have it sitting there in its own little container environment you call it necessary call it to run like an application and then just like once it&#39;s done just say okay go back yeah something like that and you have a question um yeah so i see like a big communication with the system it&#39;s based on a simple program right yeah so that
It makes me wonder like uh then we reduce all the problem of this distributed systems via this network under 115. Yeah. How does how does this how it does might be handled in some different way or if it dies reconnect. Uh there is some uh there&#39;s a tool called AAN which is basically kind of like screen but for 9 or TMUX but for 9P instead of for proper sessions. Uh and that&#39;ll kind of transparently just stall the connection.
and try reconnecting periodically until it starts working again. I believe it does some stuff to tell everything to redraw, reinitialize its stuff if you lose the connections, but I&#39;m not entirely sure. Yeah, but there&#39;s nothing magical in there. Are you using plan 9 port on the OpenBSD machine to talk to the 9 port machine or some other? Uh, drawterm. Okay. Uh, which is not plan 9 ported.
It&#39;s basically uh um it&#39;s kind of a plain nine kernel in user space that has just enough in it to mount a nine P server and run the shell script that it uses to uh import the stuff from that machine and uh pull it and do the drawing.
I&#39;m not going to go to a few utilities but nothing too but not too much. The main one I use is the plumber. So in my terminal I can right click on a URL or an email and open stuff up from there. Another way I see it is that it mounts the local file system to that namespace on that CPU server that&#39;s running in it. So you could open up an ASCII session with this bullet point and work on your local clients. Okay. Sam. Or play for your clients. Okay.
Do you see Plan 9 like, you know, five or ten years from now being a sort of more adopted level or is it always going to be a kind of, you know, academic exercise? Sorry. I&#39;m actually slightly sick. That wasn&#39;t a sarcastic comment on purpose. It was just well-timed. Okay, so basically I don&#39;t see it taking off in any commercial sense.
I think it&#39;s basically going to be same niche as haiku maybe you know people like the system they&#39;ll probably keep using it they might use it for personal stuff maybe one crazy company will try to do something but probably not unless I started and try and do it yeah but I mean you could hire the entire user base at client and still not have enough people to actually fund it or to staff a
reasonable size company I think so I don&#39;t see it I see that a loneliness being a barrier it has been used commercially because we have someone who has used to work as a lawyer and he told me I don&#39;t know if it&#39;s true he said he ran his law firm there are a number of places there are no just not on talk he&#39;s on talk but this is not on talk so there are a lot of places
have used it commercially in the past um or a lot um there are places that have used it commercially in the past uh for example there is a com a startup called Colrade which was built on that um there is so uh the Cisco PIX routers you might notice that PIX is Roman numerals P9 uh so they were based off of uh Plan 9. How?
what does that mean uh they took plan the plan 9 code wanted platform yes yeah yeah that was plan uh at least initially i&#39;m guessing that at some point cisco rewrote it but that&#39;s a guess i thought i always thought the old uh older system oses back in those days ios and so on well pick based because they&#39;re all system five or psp
So uh PIX was actually acquired by Cisco So yeah, I&#39;m guessing at some point after acquisition they kept the brand but so yeah, yeah Cool anyone else have yeah your comment on using I had to patch my terminal to make that work but
Well, I don&#39;t know. Okay. There might actually be a patch floating around that&#39;s better than the one I have. I&#39;ll look around. Okay. No questions? Okay.
</div>
<h2 id="inputs">Inputs</h2>
<ul>
<li>Video: <code>Plan_9_Not_dead,_Just_Resting,_by_Ori_Bernstein.mp4</code></li>
<li>This is an AI-generated summary of the video.</li>
<li>Duration: <code>4626.367s</code> (01:17:06)</li>
<li>Audio stream (ffprobe): codec=<code>aac</code>, sample_rate=<code>44100</code>, channels=<code>2</code>, layout=<code>stereo</code></li>
</ul>
<h2 id="output-artifacts">Output Artifacts</h2>
<ul>
<li>Extracted WAV segments: <code>audio_segments/seg_0000.wav</code> </li>
<li>Local model snapshot: <code>model/</code></li>
<li>This report: <code>report.md</code></li>
</ul>
<h2 id="commands-executed">Commands Executed</h2>
<h3 id="environment-setup-one-time">Environment setup (one-time)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>uv venv --python 3.12
</span></span><span style="display:flex;"><span>uv pip install --python .venv/bin/python torch torchaudio
</span></span><span style="display:flex;"><span>uv pip install --python .venv/bin/python <span style="color:#e6db74">&#34;nemo_toolkit[asr,tts] @ git+https://github.com/NVIDIA/NeMo.git&#34;</span>
</span></span></code></pre></div><h3 id="model-download-hugging-face">Model download (Hugging Face)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir -p model hf_home
</span></span><span style="display:flex;"><span>HF_HOME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$PWD<span style="color:#e6db74">/hf_home&#34;</span> .venv/bin/hf download nvidia/canary-qwen-2.5b --cache-dir <span style="color:#e6db74">&#34;</span>$PWD<span style="color:#e6db74">/hf_home&#34;</span> --local-dir <span style="color:#e6db74">&#34;</span>$PWD<span style="color:#e6db74">/model&#34;</span>
</span></span></code></pre></div><h3 id="ffprobe">ffprobe</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ffprobe -v error -show_entries format<span style="color:#f92672">=</span>duration:stream<span style="color:#f92672">=</span>index,codec_type,codec_name,sample_rate,channels,channel_layout -of json /home/fff/Video/Plan_9_Not_dead,_Just_Resting,_by_Ori_Bernstein.mp4
</span></span></code></pre></div><h3 id="ffmpeg-video--16khz-mono-wav-segments">ffmpeg (video  16kHz mono WAV segments)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ffmpeg -y -i /home/fff/Video/Plan_9_Not_dead,_Just_Resting,_by_Ori_Bernstein.mp4 -vn -ac <span style="color:#ae81ff">1</span> -ar <span style="color:#ae81ff">16000</span> -c:a pcm_s16le -f segment -segment_time <span style="color:#ae81ff">30</span> -reset_timestamps <span style="color:#ae81ff">1</span> /home/fff/fpiorl/canary-qwen-2.5b-local/audio_segments/seg_%04d.wav
</span></span></code></pre></div><h2 id="arguments-touched-summary">Arguments Touched (Summary)</h2>
<h3 id="mkdir-arguments">mkdir arguments</h3>
<table>
  <thead>
      <tr>
          <th>Argument</th>
          <th>Value</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>-p</code></td>
          <td>(flag)</td>
          <td>Create directories if missing</td>
      </tr>
      <tr>
          <td><code>&lt;dirs&gt;</code></td>
          <td><code>model hf_home</code></td>
          <td>Directories created for snapshot + cache</td>
      </tr>
  </tbody>
</table>
<h3 id="uv--pip-arguments">uv / pip arguments</h3>
<table>
  <thead>
      <tr>
          <th>Command</th>
          <th>Argument</th>
          <th>Value</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>uv venv</code></td>
          <td><code>--python</code></td>
          <td><code>3.12</code></td>
          <td>Use Python 3.12 for the venv</td>
      </tr>
      <tr>
          <td><code>uv pip install</code></td>
          <td><code>--python</code></td>
          <td><code>.venv/bin/python</code></td>
          <td>Install packages into that venv</td>
      </tr>
      <tr>
          <td><code>uv pip install</code></td>
          <td><code>&lt;packages&gt;</code></td>
          <td><code>torch torchaudio</code></td>
          <td>PyTorch runtime dependencies</td>
      </tr>
      <tr>
          <td><code>uv pip install</code></td>
          <td><code>&lt;requirement&gt;</code></td>
          <td><code>nemo_toolkit[asr,tts] @ git+https://github.com/NVIDIA/NeMo.git</code></td>
          <td>Install NeMo from GitHub with ASR+TTS extras</td>
      </tr>
  </tbody>
</table>
<h3 id="hf-download-arguments">hf download arguments</h3>
<table>
  <thead>
      <tr>
          <th>Argument</th>
          <th>Value</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>HF_HOME</code></td>
          <td><code>$PWD/hf_home</code></td>
          <td>Env var that sets Hugging Face cache root</td>
      </tr>
      <tr>
          <td><code>repo_id</code></td>
          <td><code>nvidia/canary-qwen-2.5b</code></td>
          <td>Model repository to download</td>
      </tr>
      <tr>
          <td><code>--cache-dir</code></td>
          <td><code>$PWD/hf_home</code></td>
          <td>Where HF stores the snapshot cache</td>
      </tr>
      <tr>
          <td><code>--local-dir</code></td>
          <td><code>$PWD/model</code></td>
          <td>Where snapshot files are copied for local loading</td>
      </tr>
  </tbody>
</table>
<h3 id="ffprobe-arguments">ffprobe arguments</h3>
<table>
  <thead>
      <tr>
          <th>Argument</th>
          <th>Value</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>-v</code></td>
          <td><code>error</code></td>
          <td>Only print errors</td>
      </tr>
      <tr>
          <td><code>-show_entries</code></td>
          <td><code>format=duration:stream=...</code></td>
          <td>Select duration + stream fields to output</td>
      </tr>
      <tr>
          <td><code>-of</code></td>
          <td><code>json</code></td>
          <td>JSON output format</td>
      </tr>
      <tr>
          <td><code>&lt;input&gt;</code></td>
          <td>video path</td>
          <td>File to inspect</td>
      </tr>
  </tbody>
</table>
<h3 id="ffmpeg-arguments">ffmpeg arguments</h3>
<table>
  <thead>
      <tr>
          <th>Argument</th>
          <th>Value</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>-y</code></td>
          <td>(flag)</td>
          <td>Overwrite existing output files</td>
      </tr>
      <tr>
          <td><code>-i</code></td>
          <td>video path</td>
          <td>Input file</td>
      </tr>
      <tr>
          <td><code>-vn</code></td>
          <td>(flag)</td>
          <td>Disable video recording/output</td>
      </tr>
      <tr>
          <td><code>-ac</code></td>
          <td><code>1</code></td>
          <td>Downmix/set number of channels</td>
      </tr>
      <tr>
          <td><code>-ar</code></td>
          <td><code>16000</code></td>
          <td>Resample to target sample rate (Hz)</td>
      </tr>
      <tr>
          <td><code>-c:a</code></td>
          <td><code>pcm_s16le</code></td>
          <td>Encode audio as 16-bit PCM WAV</td>
      </tr>
      <tr>
          <td><code>-f</code></td>
          <td><code>segment</code></td>
          <td>Use the segment muxer (split into multiple files)</td>
      </tr>
      <tr>
          <td><code>-segment_time</code></td>
          <td><code>30</code></td>
          <td>Segment length in seconds</td>
      </tr>
      <tr>
          <td><code>-reset_timestamps</code></td>
          <td><code>1</code></td>
          <td>Reset timestamps per segment</td>
      </tr>
      <tr>
          <td>output pattern</td>
          <td><code>audio_segments/seg_%04d.wav</code></td>
          <td>Segment file naming template</td>
      </tr>
  </tbody>
</table>
<h3 id="nemo--salm-arguments">NeMo / SALM arguments</h3>
<table>
  <thead>
      <tr>
          <th>Call</th>
          <th>Argument</th>
          <th>Value</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>SALM.from_pretrained</code></td>
          <td><code>pretrained_model_name_or_path</code></td>
          <td><code>model/</code></td>
          <td>Load weights/config from local folder</td>
      </tr>
      <tr>
          <td><code>SALM.from_pretrained</code></td>
          <td><code>cache_dir</code></td>
          <td><code>hf_home/</code></td>
          <td>HF cache directory inside this folder</td>
      </tr>
      <tr>
          <td><code>SALM.from_pretrained</code></td>
          <td><code>local_files_only</code></td>
          <td><code>True</code></td>
          <td>Avoid downloading missing files from the internet</td>
      </tr>
      <tr>
          <td><code>model.generate</code></td>
          <td><code>prompts</code></td>
          <td>list of chat messages</td>
          <td>Batch of audio+prompt inputs</td>
      </tr>
      <tr>
          <td><code>model.generate</code></td>
          <td><code>max_new_tokens</code></td>
          <td><code>384</code></td>
          <td>Max tokens generated per segment</td>
      </tr>
      <tr>
          <td><code>transcribe</code> loop</td>
          <td><code>batch_size</code></td>
          <td><code>16</code></td>
          <td>Number of segments transcribed per <code>generate()</code> call</td>
      </tr>
  </tbody>
</table>
<h2 id="runtime">Runtime</h2>
<ul>
<li>Segments: <code>155</code></li>
<li>Total transcription time: <code>4370.3s</code> (72.8 min)</li>
<li>GPU: Intel HD Graphics 4400</li>
<li>Overall RTF (wall/audio): <code>0.94</code></li>
</ul>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim"> 2026 </div>
    <div>Made with  and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>11150 words</span>
    <span>56 - 72 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#transcript">Transcript</a></li>
    <li><a href="#inputs">Inputs</a></li>
    <li><a href="#output-artifacts">Output Artifacts</a></li>
    <li><a href="#commands-executed">Commands Executed</a>
      <ul>
        <li><a href="#environment-setup-one-time">Environment setup (one-time)</a></li>
        <li><a href="#model-download-hugging-face">Model download (Hugging Face)</a></li>
        <li><a href="#ffprobe">ffprobe</a></li>
        <li><a href="#ffmpeg-video--16khz-mono-wav-segments">ffmpeg (video  16kHz mono WAV segments)</a></li>
      </ul>
    </li>
    <li><a href="#arguments-touched-summary">Arguments Touched (Summary)</a>
      <ul>
        <li><a href="#mkdir-arguments">mkdir arguments</a></li>
        <li><a href="#uv--pip-arguments">uv / pip arguments</a></li>
        <li><a href="#hf-download-arguments">hf download arguments</a></li>
        <li><a href="#ffprobe-arguments">ffprobe arguments</a></li>
        <li><a href="#ffmpeg-arguments">ffmpeg arguments</a></li>
        <li><a href="#nemo--salm-arguments">NeMo / SALM arguments</a></li>
      </ul>
    </li>
    <li><a href="#runtime">Runtime</a></li>
  </ul>
</nav></aside></div>
  </div>
</body>
</html>
